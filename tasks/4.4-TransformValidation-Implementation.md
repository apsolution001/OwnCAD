# Task 4.4 - Transform Validation Implementation Guide

## Overview

**Goal:** Ensure all transformation operations (Move, Rotate, future Mirror) preserve geometric precision without cumulative drift, rounding errors, or loss of arc direction.

**Why This Matters (Manufacturing Context):**
- CNC machines have sub-millimeter tolerances
- Cumulative drift from repeated transforms corrupts toolpaths
- Arc direction (CCW vs CW) determines cutting side in machining
- Round-trip (transform → inverse transform) must yield identical geometry

---

## Subtasks

### 4.4.1 Create TransformValidator Utility Class
**Files to create:**
- `include/geometry/TransformValidator.h`
- `src/geometry/TransformValidator.cpp`

**Responsibilities:**
- Validate geometry equality within tolerance (GEOMETRY_EPSILON)
- Compare geometry before/after transformations
- Detect cumulative drift from repeated operations
- Report precision loss with detailed diagnostics

**Interface Design:**
```cpp
namespace OwnCAD::Geometry {

struct ValidationResult {
    bool passed;
    double maxDeviation;      // Maximum coordinate difference
    std::string failureReason; // Empty if passed
};

class TransformValidator {
public:
    // Compare two points within tolerance
    static ValidationResult comparePoints(
        const Point2D& expected,
        const Point2D& actual,
        double tolerance = GEOMETRY_EPSILON
    );

    // Compare two lines within tolerance
    static ValidationResult compareLines(
        const Line2D& expected,
        const Line2D& actual,
        double tolerance = GEOMETRY_EPSILON
    );

    // Compare two arcs within tolerance (includes direction check)
    static ValidationResult compareArcs(
        const Arc2D& expected,
        const Arc2D& actual,
        double tolerance = GEOMETRY_EPSILON
    );

    // Validate round-trip: apply transform, then inverse, compare to original
    static ValidationResult validateRoundTrip(
        const Point2D& original,
        const std::function<Point2D(const Point2D&)>& transform,
        const std::function<Point2D(const Point2D&)>& inverse,
        double tolerance = GEOMETRY_EPSILON
    );

    // Validate N repeated transforms accumulate no drift
    static ValidationResult validateRepeatedTransforms(
        const Point2D& original,
        const std::function<Point2D(const Point2D&)>& transform,
        int iterations,
        double tolerance = GEOMETRY_EPSILON
    );
};

} // namespace OwnCAD::Geometry
```

---

### 4.4.2 Implement Core Validation Tests

**Test file:** `tests/geometry/TransformValidatorTest.cpp`

#### Test Cases:

**A. Point Translation Precision**
```cpp
TEST(TransformValidation, TranslatePointPreservesPrecision) {
    Point2D p(100.123456789, 200.987654321);

    // Translate forward then back
    auto moved = GeometryMath::translate(p, 50.0, -30.0);
    auto back = GeometryMath::translate(moved, -50.0, 30.0);

    // Must be identical within GEOMETRY_EPSILON
    EXPECT_TRUE(p.isEqual(back, GEOMETRY_EPSILON));
}
```

**B. Point Rotation 360 Degrees**
```cpp
TEST(TransformValidation, Rotate360DegreesYieldsIdentical) {
    Point2D p(100.0, 50.0);
    Point2D center(0.0, 0.0);

    auto rotated = GeometryMath::rotate(p, center, 2 * M_PI);

    // Full rotation must return to original
    EXPECT_TRUE(p.isEqual(rotated, GEOMETRY_EPSILON));
}
```

**C. Line Translation Preserves Length**
```cpp
TEST(TransformValidation, TranslateLinePreservesLength) {
    auto line = Line2D::create(Point2D(0, 0), Point2D(100, 0));
    ASSERT_TRUE(line.has_value());

    auto translated = GeometryMath::translate(*line, 1000.0, 2000.0);
    ASSERT_TRUE(translated.has_value());

    // Length must be identical
    EXPECT_DOUBLE_EQ(line->length(), translated->length());
}
```

**D. Arc Direction Preserved After Rotation**
```cpp
TEST(TransformValidation, RotateArcPreservesDirection) {
    // CCW arc
    auto arc = Arc2D::create(
        Point2D(0, 0), 10.0,
        0.0, M_PI / 2,  // 0 to 90 degrees
        true  // CCW
    );
    ASSERT_TRUE(arc.has_value());

    Point2D rotationCenter(50, 50);
    auto rotated = GeometryMath::rotate(*arc, rotationCenter, M_PI / 4);
    ASSERT_TRUE(rotated.has_value());

    // Direction MUST be preserved
    EXPECT_EQ(arc->isCounterClockwise(), rotated->isCounterClockwise());
}
```

**E. Cumulative Drift Detection (Critical)**
```cpp
TEST(TransformValidation, NoCumulativeDriftAfter1000Rotations) {
    Point2D p(100.0, 0.0);
    Point2D center(0.0, 0.0);
    double smallAngle = 2 * M_PI / 1000.0;  // 0.36 degrees

    Point2D current = p;
    for (int i = 0; i < 1000; ++i) {
        current = GeometryMath::rotate(current, center, smallAngle);
    }

    // After 1000 rotations of 0.36 degrees, should be back at start
    // Allow slightly larger tolerance due to accumulation
    double drift = p.distanceTo(current);

    // Manufacturing tolerance: 0.001mm (1 micron)
    EXPECT_LT(drift, 0.001);
}
```

**F. Translate + Rotate Composition**
```cpp
TEST(TransformValidation, ComposedTransformsPreservePrecision) {
    auto line = Line2D::create(Point2D(10, 20), Point2D(50, 80));
    ASSERT_TRUE(line.has_value());

    // Apply sequence: translate → rotate → translate back → rotate back
    auto step1 = GeometryMath::translate(*line, 100, 200);
    ASSERT_TRUE(step1.has_value());

    auto step2 = GeometryMath::rotate(*step1, Point2D(0, 0), M_PI / 3);
    ASSERT_TRUE(step2.has_value());

    auto step3 = GeometryMath::rotate(*step2, Point2D(0, 0), -M_PI / 3);
    ASSERT_TRUE(step3.has_value());

    auto step4 = GeometryMath::translate(*step3, -100, -200);
    ASSERT_TRUE(step4.has_value());

    // Must match original
    EXPECT_TRUE(line->start().isEqual(step4->start(), GEOMETRY_EPSILON * 10));
    EXPECT_TRUE(line->end().isEqual(step4->end(), GEOMETRY_EPSILON * 10));
}
```

---

### 4.4.3 Arc-Specific Validation

**Why Arc Validation is Critical:**
- Arc sweep angle must remain unchanged
- Arc radius must remain unchanged
- Arc direction (CCW/CW) determines toolpath cutting direction
- Center point must transform correctly

**Test Cases:**

```cpp
TEST(TransformValidation, RotateArcPreservesSweepAngle) {
    auto arc = Arc2D::create(Point2D(0, 0), 50.0, 0.0, M_PI, true);
    ASSERT_TRUE(arc.has_value());
    double originalSweep = arc->sweepAngle();

    auto rotated = GeometryMath::rotate(*arc, Point2D(100, 100), M_PI / 6);
    ASSERT_TRUE(rotated.has_value());

    EXPECT_NEAR(originalSweep, rotated->sweepAngle(), GEOMETRY_EPSILON);
}

TEST(TransformValidation, TranslateArcPreservesRadius) {
    auto arc = Arc2D::create(Point2D(0, 0), 75.5, 0.0, M_PI, true);
    ASSERT_TRUE(arc.has_value());

    auto translated = GeometryMath::translate(*arc, 999.999, -888.888);
    ASSERT_TRUE(translated.has_value());

    EXPECT_DOUBLE_EQ(arc->radius(), translated->radius());
}

TEST(TransformValidation, FullCircleRotation) {
    // Full circle (360 degree arc)
    auto circle = Arc2D::create(Point2D(50, 50), 25.0, 0.0, 2 * M_PI, true);
    ASSERT_TRUE(circle.has_value());
    ASSERT_TRUE(circle->isFullCircle());

    auto rotated = GeometryMath::rotate(*circle, Point2D(0, 0), 1.234);
    ASSERT_TRUE(rotated.has_value());

    // Must still be a full circle
    EXPECT_TRUE(rotated->isFullCircle());
    // Radius unchanged
    EXPECT_DOUBLE_EQ(circle->radius(), rotated->radius());
}
```

---

### 4.4.4 Ellipse Validation

```cpp
TEST(TransformValidation, RotateEllipsePreservesAxes) {
    auto ellipse = Ellipse2D::create(
        Point2D(0, 0),
        Point2D(100, 0),  // Major axis end
        0.5,              // Minor ratio
        0.0, 2 * M_PI     // Full ellipse
    );
    ASSERT_TRUE(ellipse.has_value());

    double originalMajor = ellipse->majorRadius();
    double originalMinor = ellipse->minorRadius();

    auto rotated = GeometryMath::rotate(*ellipse, Point2D(50, 50), M_PI / 4);
    ASSERT_TRUE(rotated.has_value());

    // Major and minor radii must be preserved
    EXPECT_NEAR(originalMajor, rotated->majorRadius(), GEOMETRY_EPSILON);
    EXPECT_NEAR(originalMinor, rotated->minorRadius(), GEOMETRY_EPSILON);
}
```

---

### 4.4.5 Integration Test with DocumentModel

**Test:** Apply transforms to entities in DocumentModel and verify round-trip integrity.

```cpp
TEST(TransformValidation, DocumentModelTransformIntegrity) {
    DocumentModel model;

    // Add test geometry
    auto line = Line2D::create(Point2D(0, 0), Point2D(100, 100));
    auto arc = Arc2D::create(Point2D(50, 50), 30.0, 0.0, M_PI, true);

    std::string lineHandle = model.addLine(*line);
    std::string arcHandle = model.addArc(*arc);

    // Capture original state
    auto originalLine = model.getLine(lineHandle);
    auto originalArc = model.getArc(arcHandle);

    // Apply transforms via model methods (when implemented)
    // model.translateEntities({lineHandle, arcHandle}, 100, 100);
    // model.translateEntities({lineHandle, arcHandle}, -100, -100);

    // Verify geometry is unchanged
    // (This test validates the full stack: UI → Model → Geometry)
}
```

---

## Implementation Order

1. **[4.4.1]** Create `TransformValidator` class (header + implementation)
2. **[4.4.2]** Write basic point/line translation tests
3. **[4.4.3]** Write rotation precision tests (including 360° test)
4. **[4.4.4]** Write cumulative drift test (1000 iterations)
5. **[4.4.5]** Write arc direction preservation tests
6. **[4.4.6]** Write ellipse validation tests
7. **[4.4.7]** Run all tests, fix any precision issues found
8. **[4.4.8]** Document tolerance thresholds in GeometryConstants.h

---

## Files to Modify

| File | Change |
|------|--------|
| `include/geometry/TransformValidator.h` | **NEW** - Validation class header |
| `src/geometry/TransformValidator.cpp` | **NEW** - Validation class implementation |
| `tests/geometry/TransformValidatorTest.cpp` | **NEW** - All validation tests |
| `CMakeLists.txt` | Add new source files |
| `File-Structure.md` | Document new TransformValidator class |
| `include/geometry/GeometryConstants.h` | Add TRANSFORM_TOLERANCE constant if needed |

---

## Acceptance Criteria

- [ ] All point translation round-trips pass within GEOMETRY_EPSILON
- [ ] All line translation round-trips pass within GEOMETRY_EPSILON
- [ ] All arc translation round-trips pass within GEOMETRY_EPSILON
- [ ] 360° rotation returns identical geometry
- [ ] 1000 small rotations accumulate < 0.001 units drift
- [ ] Arc direction (CCW/CW) is preserved through all transforms
- [ ] Arc radius is preserved through all transforms
- [ ] Arc sweep angle is preserved through all transforms
- [ ] Ellipse axis ratios preserved through all transforms
- [ ] No test failures in CI

---

## Notes

**Precision Constants (GeometryConstants.h):**
- `GEOMETRY_EPSILON = 1e-9` - Primary tolerance for equality
- `MIN_LINE_LENGTH = 1e-9` - Degenerate line threshold
- `MIN_ARC_RADIUS = 1e-9` - Degenerate arc threshold

**Manufacturing Tolerances:**
- Typical CNC tolerance: 0.01mm
- Our target: 0.001mm (1 micron) cumulative drift maximum

**Known Floating-Point Risks:**
- `sin(2*PI)` is not exactly 0.0
- Repeated small rotations accumulate error
- Large coordinate + small delta loses precision (catastrophic cancellation)

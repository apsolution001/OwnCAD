# Task 5.4 - Undo/Redo UI Integration

## Quick Reference

| Item | Status | Notes |
|------|--------|-------|
| CommandHistory | ✅ EXISTS | `include/model/CommandHistory.h` |
| historyChanged signal | ✅ EXISTS | Emitted on stack changes |
| Ctrl+Z shortcut | ❌ MISSING | Main deliverable |
| Ctrl+Y shortcut | ❌ MISSING | Main deliverable |
| Edit menu Undo/Redo | ❌ MISSING | Main deliverable |
| Status bar feedback | ❌ MISSING | Main deliverable |

**First Action:** Add Edit menu with Undo/Redo actions in main.cpp

---

## Overview

This task creates the user interface for undo/redo functionality:
- Keyboard shortcuts (Ctrl+Z, Ctrl+Y)
- Edit menu with dynamic descriptions
- Status bar feedback on operations
- Visual state indicators

**Goal:** Users can undo/redo via keyboard or menu, with clear feedback.

---

## Objectives

- [ ] Create Edit menu with Undo and Redo actions
- [ ] Wire Ctrl+Z to undo operation
- [ ] Wire Ctrl+Y (and Ctrl+Shift+Z) to redo operation
- [ ] Dynamic menu text showing operation descriptions
- [ ] Disable menu items when undo/redo unavailable
- [ ] Status bar shows operation feedback on undo/redo
- [ ] Optional: Status bar indicator showing undo stack depth

---

## UI Design

### Edit Menu Structure

```
┌────────────────────────────────────┐
│ Edit                               │
├────────────────────────────────────┤
│ Undo Move 3 entities     Ctrl+Z   │ ← Dynamic description
│ Redo                     Ctrl+Y   │ ← Grayed out (nothing to redo)
│────────────────────────────────────│
│ Cut                      Ctrl+X   │
│ Copy                     Ctrl+C   │
│ Paste                    Ctrl+V   │
│────────────────────────────────────│
│ Delete                   Del      │
│ Select All               Ctrl+A   │
└────────────────────────────────────┘
```

### Menu Text Behavior

| State | Undo Text | Redo Text |
|-------|-----------|-----------|
| Nothing to undo | "Undo" (disabled) | "Redo" (disabled) |
| Can undo "Draw Line" | "Undo Draw Line" (enabled) | "Redo" (disabled) |
| After undo | "Undo ..." (if more) | "Redo Draw Line" (enabled) |
| After new command | "Undo ..." | "Redo" (disabled) |

### Status Bar Feedback

```
┌──────────────────────────────────────────────────────────────────────────┐
│ Ready | X: 125.00 Y: 350.00 | Zoom: 100% | Snap: Endpoint | Selected: 3 │
└──────────────────────────────────────────────────────────────────────────┘

After undo:
┌──────────────────────────────────────────────────────────────────────────┐
│ Undo: Draw Line | X: 125.00 Y: 350.00 | ...                              │
└──────────────────────────────────────────────────────────────────────────┘

After redo:
┌──────────────────────────────────────────────────────────────────────────┐
│ Redo: Draw Line | X: 125.00 Y: 350.00 | ...                              │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## Implementation Steps

### Step 1: Create Edit Menu in main.cpp

**Location:** After File menu creation, before View menu.

```cpp
// ==================== EDIT MENU ====================
QMenu* editMenu = menuBar()->addMenu("&Edit");

// Undo action
QAction* undoAction = new QAction("&Undo", this);
undoAction->setShortcut(QKeySequence::Undo);  // Ctrl+Z (platform-aware)
undoAction->setEnabled(false);  // Initially disabled
editMenu->addAction(undoAction);

// Redo action
QAction* redoAction = new QAction("&Redo", this);
redoAction->setShortcut(QKeySequence::Redo);  // Ctrl+Y or Ctrl+Shift+Z
redoAction->setEnabled(false);  // Initially disabled
editMenu->addAction(redoAction);

editMenu->addSeparator();

// Future: Cut, Copy, Paste, Delete, Select All
// (placeholder or implement based on current status)
```

### Step 2: Connect Actions to CommandHistory

```cpp
// Connect undo action
connect(undoAction, &QAction::triggered, this, [=]() {
    if (commandHistory->canUndo()) {
        commandHistory->undo();
    }
});

// Connect redo action
connect(redoAction, &QAction::triggered, this, [=]() {
    if (commandHistory->canRedo()) {
        commandHistory->redo();
    }
});
```

### Step 3: Update Menu State on History Changes

```cpp
// Update action state when history changes
connect(commandHistory, &CommandHistory::historyChanged, this, [=]() {
    // Enable/disable based on stack state
    undoAction->setEnabled(commandHistory->canUndo());
    redoAction->setEnabled(commandHistory->canRedo());

    // Update text with operation description
    if (commandHistory->canUndo()) {
        QString desc = commandHistory->undoDescription();
        undoAction->setText(QString("&Undo %1").arg(desc));
    } else {
        undoAction->setText("&Undo");
    }

    if (commandHistory->canRedo()) {
        QString desc = commandHistory->redoDescription();
        redoAction->setText(QString("&Redo %1").arg(desc));
    } else {
        redoAction->setText("&Redo");
    }
});
```

### Step 4: Status Bar Feedback

```cpp
// Show feedback on undo
connect(commandHistory, &CommandHistory::commandUndone,
        this, [=](const QString& description) {
    statusBar()->showMessage(QString("Undo: %1").arg(description), 3000);
});

// Show feedback on redo
connect(commandHistory, &CommandHistory::commandRedone,
        this, [=](const QString& description) {
    statusBar()->showMessage(QString("Redo: %1").arg(description), 3000);
});

// Show feedback on execute (optional - can be noisy)
connect(commandHistory, &CommandHistory::commandExecuted,
        this, [=](const QString& description) {
    // Short feedback, 2 seconds
    statusBar()->showMessage(description, 2000);
});
```

### Step 5: Optional - Undo Stack Depth Indicator

Add a permanent status bar widget showing undo availability:

```cpp
// Create undo indicator label
QLabel* undoIndicator = new QLabel(this);
undoIndicator->setMinimumWidth(80);
undoIndicator->setAlignment(Qt::AlignCenter);
undoIndicator->setFrameStyle(QFrame::StyledPanel | QFrame::Sunken);
statusBar()->addPermanentWidget(undoIndicator);

// Update on history changes
connect(commandHistory, &CommandHistory::historyChanged, this, [=]() {
    size_t undoCount = commandHistory->undoCount();
    size_t redoCount = commandHistory->redoCount();

    if (undoCount == 0 && redoCount == 0) {
        undoIndicator->setText("Undo: -");
        undoIndicator->setToolTip("No undo history");
    } else {
        undoIndicator->setText(QString("Undo: %1").arg(undoCount));
        undoIndicator->setToolTip(
            QString("Undo: %1 | Redo: %2").arg(undoCount).arg(redoCount)
        );
    }
});
```

---

## Complete main.cpp Integration

Here's the complete code block to add to main.cpp:

```cpp
// ============================================================
// UNDO/REDO UI INTEGRATION (Task 5.4)
// ============================================================

// Create CommandHistory (must be created before ToolManager wiring)
CommandHistory* commandHistory = new CommandHistory(mainWindow);

// Wire to ToolManager (from Task 5.3)
toolManager->setCommandHistory(commandHistory);

// ==================== EDIT MENU ====================
QMenu* editMenu = menuBar()->addMenu("&Edit");

// -- Undo Action --
QAction* undoAction = new QAction("&Undo", mainWindow);
undoAction->setShortcut(QKeySequence::Undo);  // Ctrl+Z
undoAction->setEnabled(false);
undoAction->setStatusTip("Undo the last operation");
editMenu->addAction(undoAction);

// -- Redo Action --
QAction* redoAction = new QAction("&Redo", mainWindow);
redoAction->setShortcut(QKeySequence::Redo);  // Ctrl+Y / Ctrl+Shift+Z
redoAction->setEnabled(false);
redoAction->setStatusTip("Redo the last undone operation");
editMenu->addAction(redoAction);

editMenu->addSeparator();

// -- Delete Action (uses command system) --
QAction* deleteAction = new QAction("&Delete", mainWindow);
deleteAction->setShortcut(QKeySequence::Delete);  // Del key
deleteAction->setStatusTip("Delete selected entities");
editMenu->addAction(deleteAction);

// ==================== CONNECTIONS ====================

// Undo triggered
connect(undoAction, &QAction::triggered, commandHistory, [=]() {
    if (!commandHistory->undo()) {
        statusBar()->showMessage("Nothing to undo", 2000);
    }
});

// Redo triggered
connect(redoAction, &QAction::triggered, commandHistory, [=]() {
    if (!commandHistory->redo()) {
        statusBar()->showMessage("Nothing to redo", 2000);
    }
});

// Delete triggered
connect(deleteAction, &QAction::triggered, canvas, [=]() {
    canvas->deleteSelectedEntities();
});

// History state changes → Update UI
connect(commandHistory, &CommandHistory::historyChanged, mainWindow, [=]() {
    // Update undo action
    bool canUndo = commandHistory->canUndo();
    undoAction->setEnabled(canUndo);
    if (canUndo) {
        undoAction->setText(QString("&Undo %1").arg(commandHistory->undoDescription()));
    } else {
        undoAction->setText("&Undo");
    }

    // Update redo action
    bool canRedo = commandHistory->canRedo();
    redoAction->setEnabled(canRedo);
    if (canRedo) {
        redoAction->setText(QString("&Redo %1").arg(commandHistory->redoDescription()));
    } else {
        redoAction->setText("&Redo");
    }

    // Trigger canvas redraw (entities may have changed)
    canvas->update();
});

// Status bar feedback on operations
connect(commandHistory, &CommandHistory::commandExecuted, mainWindow,
        [=](const QString& desc) {
    statusBar()->showMessage(desc, 2000);
});

connect(commandHistory, &CommandHistory::commandUndone, mainWindow,
        [=](const QString& desc) {
    statusBar()->showMessage(QString("Undo: %1").arg(desc), 3000);
});

connect(commandHistory, &CommandHistory::commandRedone, mainWindow,
        [=](const QString& desc) {
    statusBar()->showMessage(QString("Redo: %1").arg(desc), 3000);
});

// ==================== UNDO INDICATOR (Optional) ====================
QLabel* undoIndicator = new QLabel(mainWindow);
undoIndicator->setMinimumWidth(70);
undoIndicator->setAlignment(Qt::AlignCenter);
undoIndicator->setText("Undo: -");
undoIndicator->setToolTip("Undo history depth");
statusBar()->addPermanentWidget(undoIndicator);

connect(commandHistory, &CommandHistory::historyChanged, undoIndicator, [=]() {
    size_t count = commandHistory->undoCount();
    undoIndicator->setText(QString("Undo: %1").arg(count));
});
```

---

## Additional Shortcuts (Optional)

### Alternative Redo Shortcut

Some users expect Ctrl+Shift+Z for redo (common in many applications):

```cpp
// Add alternative shortcut
QShortcut* redoShortcut2 = new QShortcut(
    QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_Z),
    mainWindow
);
connect(redoShortcut2, &QShortcut::activated, commandHistory, &CommandHistory::redo);
```

### Repeat Last Command (Future Enhancement)

```cpp
// Ctrl+R or F4 to repeat last command
// This would require storing/cloning the last command
// Deferred to future phase
```

---

## Verification Checklist

### Keyboard Shortcuts

- [ ] Ctrl+Z triggers undo
- [ ] Ctrl+Y triggers redo
- [ ] Ctrl+Shift+Z triggers redo (if implemented)
- [ ] Shortcuts work when canvas has focus
- [ ] Shortcuts work when other widgets have focus (menu bar, etc.)

### Menu Behavior

- [ ] Edit menu appears in menu bar
- [ ] "Undo" shows in menu
- [ ] "Redo" shows in menu
- [ ] Undo disabled when nothing to undo
- [ ] Redo disabled when nothing to redo
- [ ] Undo text shows operation: "Undo Draw Line"
- [ ] Redo text shows operation: "Redo Draw Line"
- [ ] Clicking menu item triggers operation

### Status Bar

- [ ] Shows message on command execute
- [ ] Shows "Undo: ..." on undo
- [ ] Shows "Redo: ..." on redo
- [ ] Message clears after timeout
- [ ] Undo indicator shows correct count (if implemented)

### State Consistency

- [ ] Canvas redraws after undo/redo
- [ ] Selection clears appropriately after undo delete
- [ ] Menu state updates immediately after operation
- [ ] Multiple rapid undo/redo works correctly

---

## Edge Cases

### Focus Issues

Qt shortcuts require proper focus handling:
```cpp
// Ensure shortcuts work globally in main window
undoAction->setShortcutContext(Qt::ApplicationShortcut);
redoAction->setShortcutContext(Qt::ApplicationShortcut);
```

### Undo During Tool Operation

If user presses Ctrl+Z while a tool is active:
- Should undo complete previous operation
- Should NOT interfere with current tool state
- Tool preview should remain visible

**Recommendation:** Undo during tool operation should cancel the current tool first, or be ignored while tool is in InProgress state.

```cpp
// In undo action handler:
connect(undoAction, &QAction::triggered, this, [=]() {
    // Cancel any active tool operation first
    if (toolManager->currentTool() &&
        toolManager->currentTool()->state() == Tool::State::InProgress) {
        toolManager->currentTool()->cancel();
    }

    commandHistory->undo();
});
```

### Empty Document After Undo

When undoing the only entity:
- Document becomes empty
- Canvas should show empty state gracefully
- No crashes or visual artifacts

### Redo Stack Clearing

When user makes a new edit after undo:
- Redo stack clears (standard behavior)
- "Redo" becomes disabled
- No way to recover previous redo history (by design)

---

## Platform Considerations

### macOS
- Qt's `QKeySequence::Undo` maps to Cmd+Z
- Qt's `QKeySequence::Redo` maps to Cmd+Shift+Z (not Cmd+Y)
- Menu accelerator style may differ

### Windows
- Ctrl+Z for undo
- Ctrl+Y for redo (standard)
- Ctrl+Shift+Z also works (Office-style)

### Linux
- Same as Windows typically
- Some desktops may vary

**Solution:** Use `QKeySequence::Undo` and `QKeySequence::Redo` for platform-appropriate defaults.

---

## Dependencies

### Required Before This Task
- Task 5.1: Command Pattern Architecture (✅ EXISTS)
- Task 5.3: Command Stack Integration (tools wired to commands)

### Required After This Task
- Task 5.5: Stress Testing (verify 100+ undo/redo cycles)

---

## Summary

| Component | Implementation |
|-----------|---------------|
| Undo shortcut | `QKeySequence::Undo` (Ctrl+Z) |
| Redo shortcut | `QKeySequence::Redo` (Ctrl+Y/Cmd+Shift+Z) |
| Menu location | Edit menu, first two items |
| Menu text | Dynamic: "Undo {description}" |
| Status feedback | 2-3 second temporary message |
| State binding | `historyChanged` signal → UI update |

**Key Principle:** UI should always reflect the true state of CommandHistory. Never show "Undo" as enabled if `canUndo()` returns false.

---

END OF TASK 5.4

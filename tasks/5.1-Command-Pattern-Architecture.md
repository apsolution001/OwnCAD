# Task 5.1 - Command Pattern Architecture

## Overview

Implement the foundational Command pattern infrastructure for the Undo/Redo system. This task creates the base interfaces and command history management that all editing operations will use.

---

## Objectives

- [ ] Create abstract `Command` base class with execute/undo/redo interface
- [ ] Create `CommandHistory` class to manage undo/redo stacks
- [ ] Integrate with `DocumentModel` for entity modification tracking
- [ ] Wire up keyboard shortcuts (Ctrl+Z, Ctrl+Y)
- [ ] Add Edit menu items with descriptions
- [ ] Update status bar with undo/redo availability

---

## Architecture Design

### Class Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Command (Abstract)                        │
├─────────────────────────────────────────────────────────────────┤
│ + execute() : bool          [pure virtual]                       │
│ + undo() : bool             [pure virtual]                       │
│ + redo() : bool             [virtual, default calls execute()]   │
│ + description() : QString   [pure virtual]                       │
│ + isValid() : bool          [virtual, default true]              │
│ + canMerge(Command*) : bool [virtual, default false]             │
│ + merge(Command*) : bool    [virtual, default false]             │
├─────────────────────────────────────────────────────────────────┤
│ # m_documentModel : DocumentModel*                               │
│ # m_executed : bool                                              │
│ # m_timestamp : QDateTime                                        │
└─────────────────────────────────────────────────────────────────┘
                              △
                              │ inherits
          ┌───────────────────┼───────────────────┐
          │                   │                   │
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│CreateEntityCmd  │  │DeleteEntityCmd  │  │MoveEntitiesCmd  │
│(Task 5.2)       │  │(Task 5.2)       │  │(Task 5.2)       │
└─────────────────┘  └─────────────────┘  └─────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      CommandHistory                              │
├─────────────────────────────────────────────────────────────────┤
│ + executeCommand(unique_ptr<Command>) : bool                     │
│ + undo() : bool                                                  │
│ + redo() : bool                                                  │
│ + canUndo() : bool                                               │
│ + canRedo() : bool                                               │
│ + clear()                                                        │
│ + undoDescription() : QString                                    │
│ + redoDescription() : QString                                    │
│ + undoCount() : size_t                                           │
│ + redoCount() : size_t                                           │
│ + setMaxHistorySize(size_t)                                      │
├─────────────────────────────────────────────────────────────────┤
│ - m_undoStack : std::vector<unique_ptr<Command>>                 │
│ - m_redoStack : std::vector<unique_ptr<Command>>                 │
│ - m_maxHistorySize : size_t (default 100)                        │
├─────────────────────────────────────────────────────────────────┤
│ signals:                                                         │
│   historyChanged()                                               │
│   commandExecuted(QString description)                           │
│   commandUndone(QString description)                             │
│   commandRedone(QString description)                             │
└─────────────────────────────────────────────────────────────────┘
```

### Ownership & Lifetime

```
MainWindow
    │
    ├── DocumentModel (owns entities)
    │
    └── CommandHistory (owns Command objects)
            │
            └── Commands (hold raw pointer to DocumentModel)
```

**Important:** Commands do NOT own DocumentModel. They receive a raw pointer and must not outlive the DocumentModel.

---

## File Locations

### New Files to Create

| File | Location | Responsibility |
|------|----------|----------------|
| `Command.h` | `include/model/` | Abstract command interface |
| `CommandHistory.h` | `include/model/` | Undo/redo stack management |
| `CommandHistory.cpp` | `src/model/` | CommandHistory implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `CMakeLists.txt` | Add new source files |
| `main.cpp` | Add CommandHistory, keyboard shortcuts, menu items |
| `DocumentModel.h` | Add methods for entity modification (if needed) |

---

## Implementation Steps

### Step 1: Create Command Interface (`include/model/Command.h`)

```cpp
#ifndef COMMAND_H
#define COMMAND_H

#include <QString>
#include <QDateTime>
#include <memory>

class DocumentModel;

/**
 * @brief Abstract base class for all undoable commands.
 *
 * Commands encapsulate operations that modify the DocumentModel.
 * Each command must be able to execute, undo, and describe itself.
 *
 * INVARIANTS:
 * - execute() must be called before undo()
 * - undo() must be called before redo()
 * - Commands are single-use: execute() should only be called once
 */
class Command {
public:
    explicit Command(DocumentModel* model);
    virtual ~Command() = default;

    // Non-copyable, non-movable (commands own resources)
    Command(const Command&) = delete;
    Command& operator=(const Command&) = delete;
    Command(Command&&) = delete;
    Command& operator=(Command&&) = delete;

    /**
     * @brief Execute the command (first time).
     * @return true if successful, false if failed
     *
     * Implementations must:
     * - Validate preconditions
     * - Perform the operation
     * - Store state needed for undo
     * - Set m_executed = true on success
     */
    virtual bool execute() = 0;

    /**
     * @brief Reverse the command's effect.
     * @return true if successful, false if failed
     *
     * Implementations must:
     * - Restore previous state exactly
     * - Set m_executed = false on success
     */
    virtual bool undo() = 0;

    /**
     * @brief Re-apply the command after undo.
     * @return true if successful, false if failed
     *
     * Default implementation calls execute().
     * Override only if redo differs from initial execute.
     */
    virtual bool redo();

    /**
     * @brief Human-readable description for UI.
     * @return Description like "Draw Line" or "Move 5 entities"
     */
    virtual QString description() const = 0;

    /**
     * @brief Check if command is in valid state.
     * @return true if command can be executed
     */
    virtual bool isValid() const;

    /**
     * @brief Check if this command can merge with another.
     * @param other The command to potentially merge with
     * @return true if merge is possible
     *
     * Used for combining rapid successive edits (e.g., typing).
     * Default returns false (no merging).
     */
    virtual bool canMerge(const Command* other) const;

    /**
     * @brief Merge another command into this one.
     * @param other The command to absorb
     * @return true if merge succeeded
     *
     * Precondition: canMerge(other) returned true.
     */
    virtual bool merge(const Command* other);

    // Accessors
    bool isExecuted() const { return m_executed; }
    QDateTime timestamp() const { return m_timestamp; }

protected:
    DocumentModel* m_documentModel;  // Non-owning pointer
    bool m_executed = false;
    QDateTime m_timestamp;
};

#endif // COMMAND_H
```

### Step 2: Create CommandHistory (`include/model/CommandHistory.h`)

```cpp
#ifndef COMMANDHISTORY_H
#define COMMANDHISTORY_H

#include <QObject>
#include <QString>
#include <vector>
#include <memory>

class Command;

/**
 * @brief Manages undo/redo stacks for command history.
 *
 * INVARIANTS:
 * - Executing a new command clears the redo stack
 * - Undo moves command from undo stack to redo stack
 * - Redo moves command from redo stack to undo stack
 * - Stack size is bounded by maxHistorySize
 *
 * THREAD SAFETY: Not thread-safe. All calls must be from UI thread.
 */
class CommandHistory : public QObject {
    Q_OBJECT

public:
    explicit CommandHistory(QObject* parent = nullptr);
    ~CommandHistory() override;

    /**
     * @brief Execute a command and add to history.
     * @param command The command to execute (ownership transferred)
     * @return true if execution succeeded
     *
     * On success:
     * - Command is pushed to undo stack
     * - Redo stack is cleared
     * - historyChanged() signal emitted
     *
     * On failure:
     * - Command is discarded
     * - Stacks unchanged
     */
    bool executeCommand(std::unique_ptr<Command> command);

    /**
     * @brief Undo the most recent command.
     * @return true if undo succeeded, false if nothing to undo
     */
    bool undo();

    /**
     * @brief Redo the most recently undone command.
     * @return true if redo succeeded, false if nothing to redo
     */
    bool redo();

    // State queries
    bool canUndo() const;
    bool canRedo() const;
    QString undoDescription() const;
    QString redoDescription() const;
    size_t undoCount() const;
    size_t redoCount() const;

    /**
     * @brief Clear all history (e.g., on document close).
     */
    void clear();

    /**
     * @brief Set maximum history size.
     * @param size Max commands to keep (oldest discarded first)
     *
     * Default is 100. Set to 0 for unlimited (not recommended).
     */
    void setMaxHistorySize(size_t size);
    size_t maxHistorySize() const { return m_maxHistorySize; }

signals:
    /**
     * @brief Emitted when undo/redo availability changes.
     */
    void historyChanged();

    /**
     * @brief Emitted after a command is executed.
     * @param description The command's description
     */
    void commandExecuted(const QString& description);

    /**
     * @brief Emitted after a command is undone.
     * @param description The undone command's description
     */
    void commandUndone(const QString& description);

    /**
     * @brief Emitted after a command is redone.
     * @param description The redone command's description
     */
    void commandRedone(const QString& description);

private:
    void trimUndoStack();  // Enforce max size

    std::vector<std::unique_ptr<Command>> m_undoStack;
    std::vector<std::unique_ptr<Command>> m_redoStack;
    size_t m_maxHistorySize = 100;
};

#endif // COMMANDHISTORY_H
```

### Step 3: Implement CommandHistory (`src/model/CommandHistory.cpp`)

```cpp
#include "model/CommandHistory.h"
#include "model/Command.h"
#include <QDebug>

CommandHistory::CommandHistory(QObject* parent)
    : QObject(parent)
{
}

CommandHistory::~CommandHistory() = default;

bool CommandHistory::executeCommand(std::unique_ptr<Command> command)
{
    if (!command) {
        qWarning() << "CommandHistory: null command";
        return false;
    }

    if (!command->isValid()) {
        qWarning() << "CommandHistory: invalid command:" << command->description();
        return false;
    }

    if (!command->execute()) {
        qWarning() << "CommandHistory: execute failed:" << command->description();
        return false;
    }

    // Clear redo stack on new command (standard behavior)
    m_redoStack.clear();

    // Add to undo stack
    m_undoStack.push_back(std::move(command));
    trimUndoStack();

    QString desc = m_undoStack.back()->description();
    emit commandExecuted(desc);
    emit historyChanged();

    return true;
}

bool CommandHistory::undo()
{
    if (!canUndo()) {
        return false;
    }

    auto command = std::move(m_undoStack.back());
    m_undoStack.pop_back();

    if (!command->undo()) {
        qWarning() << "CommandHistory: undo failed:" << command->description();
        // Command is lost - this is a serious error
        emit historyChanged();
        return false;
    }

    QString desc = command->description();
    m_redoStack.push_back(std::move(command));

    emit commandUndone(desc);
    emit historyChanged();

    return true;
}

bool CommandHistory::redo()
{
    if (!canRedo()) {
        return false;
    }

    auto command = std::move(m_redoStack.back());
    m_redoStack.pop_back();

    if (!command->redo()) {
        qWarning() << "CommandHistory: redo failed:" << command->description();
        // Command is lost - this is a serious error
        emit historyChanged();
        return false;
    }

    QString desc = command->description();
    m_undoStack.push_back(std::move(command));

    emit commandRedone(desc);
    emit historyChanged();

    return true;
}

bool CommandHistory::canUndo() const
{
    return !m_undoStack.empty();
}

bool CommandHistory::canRedo() const
{
    return !m_redoStack.empty();
}

QString CommandHistory::undoDescription() const
{
    if (m_undoStack.empty()) {
        return QString();
    }
    return m_undoStack.back()->description();
}

QString CommandHistory::redoDescription() const
{
    if (m_redoStack.empty()) {
        return QString();
    }
    return m_redoStack.back()->description();
}

size_t CommandHistory::undoCount() const
{
    return m_undoStack.size();
}

size_t CommandHistory::redoCount() const
{
    return m_redoStack.size();
}

void CommandHistory::clear()
{
    m_undoStack.clear();
    m_redoStack.clear();
    emit historyChanged();
}

void CommandHistory::setMaxHistorySize(size_t size)
{
    m_maxHistorySize = size;
    trimUndoStack();
}

void CommandHistory::trimUndoStack()
{
    if (m_maxHistorySize == 0) {
        return;  // Unlimited
    }

    while (m_undoStack.size() > m_maxHistorySize) {
        m_undoStack.erase(m_undoStack.begin());  // Remove oldest
    }
}
```

### Step 4: Implement Command Base (`include/model/Command.h` implementation)

The `Command.h` is header-only for the abstract class, but add inline implementations:

```cpp
// At the end of Command.h, before #endif

inline Command::Command(DocumentModel* model)
    : m_documentModel(model)
    , m_timestamp(QDateTime::currentDateTime())
{
}

inline bool Command::redo()
{
    // Default: redo is same as execute
    return execute();
}

inline bool Command::isValid() const
{
    return m_documentModel != nullptr;
}

inline bool Command::canMerge(const Command* /*other*/) const
{
    return false;
}

inline bool Command::merge(const Command* /*other*/)
{
    return false;
}
```

### Step 5: Update CMakeLists.txt

Add to the source files list:
```cmake
# In the SOURCES section, add:
src/model/CommandHistory.cpp

# In the HEADERS section, add:
include/model/Command.h
include/model/CommandHistory.h
```

### Step 6: UI Integration in main.cpp

```cpp
// Add includes
#include "model/CommandHistory.h"

// In MainWindow setup, after DocumentModel creation:
CommandHistory* commandHistory = new CommandHistory(this);

// Create Edit menu actions
QMenu* editMenu = menuBar()->addMenu("&Edit");

QAction* undoAction = editMenu->addAction("&Undo");
undoAction->setShortcut(QKeySequence::Undo);  // Ctrl+Z
undoAction->setEnabled(false);

QAction* redoAction = editMenu->addAction("&Redo");
redoAction->setShortcut(QKeySequence::Redo);  // Ctrl+Y / Ctrl+Shift+Z
redoAction->setEnabled(false);

// Connect actions
connect(undoAction, &QAction::triggered, commandHistory, &CommandHistory::undo);
connect(redoAction, &QAction::triggered, commandHistory, &CommandHistory::redo);

// Update action state when history changes
connect(commandHistory, &CommandHistory::historyChanged, [=]() {
    undoAction->setEnabled(commandHistory->canUndo());
    redoAction->setEnabled(commandHistory->canRedo());

    // Update action text with description
    if (commandHistory->canUndo()) {
        undoAction->setText(QString("&Undo %1").arg(commandHistory->undoDescription()));
    } else {
        undoAction->setText("&Undo");
    }

    if (commandHistory->canRedo()) {
        redoAction->setText(QString("&Redo %1").arg(commandHistory->redoDescription()));
    } else {
        redoAction->setText("&Redo");
    }
});

// Status bar feedback
connect(commandHistory, &CommandHistory::commandExecuted, [=](const QString& desc) {
    statusBar()->showMessage(desc, 2000);
});
connect(commandHistory, &CommandHistory::commandUndone, [=](const QString& desc) {
    statusBar()->showMessage(QString("Undo: %1").arg(desc), 2000);
});
connect(commandHistory, &CommandHistory::commandRedone, [=](const QString& desc) {
    statusBar()->showMessage(QString("Redo: %1").arg(desc), 2000);
});
```

---

## Verification Checklist

### Unit Tests (`tests/model/test_CommandHistory.cpp`)

```cpp
// Test cases to implement:
- [ ] Execute single command
- [ ] Undo single command
- [ ] Redo single command
- [ ] Execute clears redo stack
- [ ] Undo/redo with empty stack returns false
- [ ] canUndo/canRedo correctness
- [ ] Description updates correctly
- [ ] Max history size enforced
- [ ] Clear() empties both stacks
- [ ] Invalid command rejected
- [ ] Failed execute not added to history
- [ ] Signals emitted correctly
```

### Manual Testing

1. **Basic Flow:**
   - Execute a command (once Task 5.2 provides CreateEntityCommand)
   - Verify Ctrl+Z undoes it
   - Verify Ctrl+Y redoes it

2. **Edge Cases:**
   - Ctrl+Z with nothing to undo (should do nothing)
   - Ctrl+Y with nothing to redo (should do nothing)
   - Execute new command clears redo stack

3. **UI Feedback:**
   - Menu shows "Undo Draw Line" (with description)
   - Menu items disabled when no undo/redo available
   - Status bar shows feedback on undo/redo

---

## Dependencies

### Required Before This Task
- DocumentModel must be stable (✅ already exists)

### Required After This Task
- Task 5.2: Command Implementations (CreateEntity, Delete, Move, etc.)
- Tool integration (LineTool, ArcTool, etc. must create commands)

---

## Notes

### Design Decisions

1. **Why `std::unique_ptr` for commands?**
   - Commands are single-owner resources
   - Stack owns them, transfers on undo/redo
   - No shared ownership needed

2. **Why signals instead of callbacks?**
   - Qt idiom for loose coupling
   - Multiple listeners possible
   - Easy to test (can verify signals fired)

3. **Why bounded history?**
   - Memory safety (100 commands = reasonable limit)
   - CAD operations can be memory-heavy (geometry copies)
   - User rarely needs 1000+ undos

4. **Why merge capability?**
   - Future: combining rapid keypresses
   - Future: combining incremental drags
   - Not needed for Phase 1 but designed in

### Edge Cases Handled

- Null command rejected
- Invalid command rejected
- Failed execute not added to history
- Failed undo/redo loses command (logged as error)
- Empty stack operations return false safely

---

## Time Estimate

This task creates infrastructure only - no visible user changes until Task 5.2 (Command Implementations) is complete.

**Files to create:** 3 (Command.h, CommandHistory.h, CommandHistory.cpp)
**Files to modify:** 2 (CMakeLists.txt, main.cpp)
**Test file:** 1 (test_CommandHistory.cpp)

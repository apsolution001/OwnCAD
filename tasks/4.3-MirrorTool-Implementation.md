# Task 4.3 - Mirror Tool Implementation

## Overview

Implement the MirrorTool class for mirroring selected entities across a user-defined axis. The `MirrorEntitiesCommand` already exists in `EntityCommands.h/.cpp` - this task creates the UI tool that uses it.

---

## Prerequisites (Already Implemented)

- [x] `GeometryMath::mirror()` for Point2D, Line2D, Arc2D, Ellipse2D (`GeometryMath.h:356-386`)
- [x] `MirrorEntitiesCommand` (`EntityCommands.h:230-260`, `EntityCommands.cpp:604-747`)
- [x] `CommandHistory` integration (`CommandHistory.h/.cpp`)
- [x] Tool base class (`Tool.h`)
- [x] ToolManager for tool registration (`ToolManager.h/.cpp`)
- [x] Selection system (`SelectionManager.h/.cpp`)

---

## Objectives

- [ ] Create `MirrorTool` class following `MoveTool`/`RotateTool` pattern
- [ ] Implement 3-click workflow: axis point 1 → axis point 2 → commit
- [ ] Add "keep original" toggle (Tab key to toggle)
- [ ] Support X-axis (horizontal) and Y-axis (vertical) shortcuts
- [ ] Add preview rendering of mirrored entities
- [ ] Wire up to main.cpp (Tools menu, keyboard shortcut)

---

## Architecture Design

### State Machine

```
┌──────────────┐
│   Inactive   │
└──────┬───────┘
       │ activate() with selection
       ▼
┌──────────────────────┐
│ WaitingForAxisPoint1 │ ← "MIRROR: Click first axis point (or X/Y for quick axis)"
└──────┬───────────────┘
       │ left-click OR X/Y key
       ▼
┌──────────────────────┐
│ WaitingForAxisPoint2 │ ← "MIRROR: Click second axis point (Tab: toggle keep/delete)"
└──────┬───────────────┘
       │ left-click
       ▼
┌──────────────┐
│    Commit    │ → Execute MirrorEntitiesCommand
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Inactive   │
└──────────────┘
```

### Quick Axis Shortcuts (Phase: WaitingForAxisPoint1)

| Key | Action | Axis Points |
|-----|--------|-------------|
| X | Mirror over horizontal axis through selection center | (center.x - 100, center.y) → (center.x + 100, center.y) |
| Y | Mirror over vertical axis through selection center | (center.x, center.y - 100) → (center.x, center.y + 100) |

---

## File Locations

### New Files to Create

| File | Location | Responsibility |
|------|----------|----------------|
| `MirrorTool.h` | `include/ui/` | Mirror tool class declaration |
| `MirrorTool.cpp` | `src/ui/` | Mirror tool implementation |

### Files to Modify

| File | Changes |
|------|---------|
| `CMakeLists.txt` | Add MirrorTool source files |
| `ToolManager.cpp` | Register MirrorTool instance |
| `main.cpp` | Add Tools menu item + keyboard shortcut |

---

## Implementation Steps

### Step 1: Create MirrorTool Header (`include/ui/MirrorTool.h`)

```cpp
#pragma once

#include "ui/Tool.h"
#include "geometry/Point2D.h"
#include <optional>
#include <vector>
#include <string>

namespace OwnCAD {
namespace UI {

/**
 * @brief Tool for mirroring selected entities across a user-defined axis.
 *
 * Workflow:
 * 1. Select entities (before activating tool)
 * 2. Activate tool → WaitingForAxisPoint1
 * 3. Click first axis point (or press X/Y for quick axis)
 * 4. Click second axis point → preview shown
 * 5. Click to commit mirror
 *
 * Features:
 * - Tab key toggles keep/delete original
 * - X key: quick horizontal axis through selection center
 * - Y key: quick vertical axis through selection center
 * - ESC: cancel and return to select mode
 */
class MirrorTool : public Tool {
public:
    MirrorTool();
    ~MirrorTool() override = default;

    // Tool interface
    void activate() override;
    void deactivate() override;
    QString statusPrompt() const override;

    ToolResult handleMousePress(const Geometry::Point2D& worldPos, QMouseEvent* event) override;
    ToolResult handleMouseMove(const Geometry::Point2D& worldPos, QMouseEvent* event) override;
    ToolResult handleMouseRelease(const Geometry::Point2D& worldPos, QMouseEvent* event) override;
    ToolResult handleKeyPress(QKeyEvent* event) override;

    void render(QPainter& painter, const Viewport& viewport) override;

    // Selection management (called before activation)
    void setSelectedHandles(const std::vector<std::string>& handles);

private:
    enum class MirrorState {
        Inactive,
        WaitingForAxisPoint1,
        WaitingForAxisPoint2
    };

    // Rendering helpers
    void renderAxisPreview(QPainter& painter, const Viewport& viewport);
    void renderMirroredEntitiesPreview(QPainter& painter, const Viewport& viewport);
    void renderEntityMirrored(QPainter& painter, const Viewport& viewport,
                               const std::string& handle);

    // Commit the mirror operation
    bool commitMirror();

    // Calculate selection center for quick axis shortcuts
    Geometry::Point2D calculateSelectionCenter() const;

    // Reset state
    void resetToAxisPoint1();
    void cancel();

    // State
    MirrorState mirrorState_ = MirrorState::Inactive;
    std::vector<std::string> selectedHandles_;

    // Mirror axis definition
    std::optional<Geometry::Point2D> axisPoint1_;
    std::optional<Geometry::Point2D> axisPoint2_;
    std::optional<Geometry::Point2D> currentPoint_;  // For live preview

    // Options
    bool keepOriginal_ = false;  // Tab toggles this

    // Rendering constants
    static constexpr int AXIS_LINE_WIDTH = 2;
    static constexpr int PREVIEW_LINE_WIDTH = 2;
    static constexpr int POINT_MARKER_SIZE = 8;
};

} // namespace UI
} // namespace OwnCAD
```

### Step 2: Create MirrorTool Implementation (`src/ui/MirrorTool.cpp`)

```cpp
#include "ui/MirrorTool.h"
#include "ui/CADCanvas.h"
#include "model/DocumentModel.h"
#include "model/CommandHistory.h"
#include "model/EntityCommands.h"
#include "geometry/GeometryMath.h"
#include "geometry/GeometryConstants.h"
#include "geometry/BoundingBox.h"
#include "import/GeometryConverter.h"
#include <QPen>
#include <QBrush>
#include <QDebug>

namespace OwnCAD {
namespace UI {

using namespace OwnCAD::Geometry;
using namespace OwnCAD::Import;

MirrorTool::MirrorTool() = default;

void MirrorTool::setSelectedHandles(const std::vector<std::string>& handles) {
    selectedHandles_ = handles;
}

void MirrorTool::activate() {
    if (selectedHandles_.empty()) {
        qWarning() << "MirrorTool: No entities selected - cannot activate";
        mirrorState_ = MirrorState::Inactive;
        return;
    }

    resetToAxisPoint1();
    mirrorState_ = MirrorState::WaitingForAxisPoint1;
    qDebug() << "MirrorTool: Activated with" << selectedHandles_.size() << "entities";
}

void MirrorTool::deactivate() {
    cancel();
    qDebug() << "MirrorTool: Deactivated";
}

QString MirrorTool::statusPrompt() const {
    switch (mirrorState_) {
        case MirrorState::Inactive:
            return QString();
        case MirrorState::WaitingForAxisPoint1:
            return QStringLiteral("MIRROR: Click first axis point (X=horiz, Y=vert, Tab=toggle copy)");
        case MirrorState::WaitingForAxisPoint2:
            return QString("MIRROR: Click second axis point [%1] (ESC to cancel)")
                .arg(keepOriginal_ ? "COPY" : "REPLACE");
    }
    return QString();
}

ToolResult MirrorTool::handleMousePress(
    const Geometry::Point2D& worldPos,
    QMouseEvent* event
) {
    if (event->button() != Qt::LeftButton) {
        return ToolResult::Ignored;
    }

    if (mirrorState_ == MirrorState::WaitingForAxisPoint1) {
        axisPoint1_ = worldPos;
        currentPoint_ = worldPos;
        mirrorState_ = MirrorState::WaitingForAxisPoint2;
        qDebug() << "MirrorTool: Axis point 1 set at" << worldPos.x() << "," << worldPos.y();
        return ToolResult::Continue;
    }
    else if (mirrorState_ == MirrorState::WaitingForAxisPoint2) {
        axisPoint2_ = worldPos;

        if (commitMirror()) {
            qDebug() << "MirrorTool: Mirror committed";
            cancel();
            return ToolResult::Completed;
        } else {
            qDebug() << "MirrorTool: Mirror failed";
            return ToolResult::Continue;
        }
    }

    return ToolResult::Ignored;
}

ToolResult MirrorTool::handleMouseMove(
    const Geometry::Point2D& worldPos,
    QMouseEvent* /*event*/
) {
    currentPoint_ = worldPos;

    if (mirrorState_ == MirrorState::WaitingForAxisPoint2) {
        return ToolResult::Continue;
    }

    return ToolResult::Ignored;
}

ToolResult MirrorTool::handleMouseRelease(
    const Geometry::Point2D& /*worldPos*/,
    QMouseEvent* /*event*/
) {
    return ToolResult::Ignored;
}

ToolResult MirrorTool::handleKeyPress(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        if (mirrorState_ == MirrorState::WaitingForAxisPoint2) {
            resetToAxisPoint1();
            qDebug() << "MirrorTool: Axis cancelled, waiting for first point";
            return ToolResult::Continue;
        }
        else if (mirrorState_ == MirrorState::WaitingForAxisPoint1) {
            cancel();
            qDebug() << "MirrorTool: Tool exited";
            return ToolResult::Cancelled;
        }
    }
    else if (event->key() == Qt::Key_Tab) {
        // Toggle keep original
        keepOriginal_ = !keepOriginal_;
        qDebug() << "MirrorTool: Keep original =" << keepOriginal_;
        return ToolResult::Continue;
    }
    else if (mirrorState_ == MirrorState::WaitingForAxisPoint1) {
        // Quick axis shortcuts
        Point2D center = calculateSelectionCenter();

        if (event->key() == Qt::Key_X) {
            // Horizontal axis (mirror over X-axis through selection center)
            axisPoint1_ = Point2D(center.x() - 1000, center.y());
            axisPoint2_ = Point2D(center.x() + 1000, center.y());

            if (commitMirror()) {
                cancel();
                return ToolResult::Completed;
            }
            return ToolResult::Continue;
        }
        else if (event->key() == Qt::Key_Y) {
            // Vertical axis (mirror over Y-axis through selection center)
            axisPoint1_ = Point2D(center.x(), center.y() - 1000);
            axisPoint2_ = Point2D(center.x(), center.y() + 1000);

            if (commitMirror()) {
                cancel();
                return ToolResult::Completed;
            }
            return ToolResult::Continue;
        }
    }

    return ToolResult::Ignored;
}

void MirrorTool::render(QPainter& painter, const Viewport& viewport) {
    if (mirrorState_ == MirrorState::Inactive) {
        return;
    }

    painter.save();

    // Draw axis line preview
    renderAxisPreview(painter, viewport);

    // Draw mirrored entities preview
    if (mirrorState_ == MirrorState::WaitingForAxisPoint2 && axisPoint1_ && currentPoint_) {
        renderMirroredEntitiesPreview(painter, viewport);
    }

    painter.restore();
}

void MirrorTool::renderAxisPreview(QPainter& painter, const Viewport& viewport) {
    if (!axisPoint1_) {
        return;
    }

    Point2D p1 = *axisPoint1_;
    Point2D p2 = currentPoint_ ? *currentPoint_ : p1;

    QPointF screenP1 = viewport.worldToScreen(p1);
    QPointF screenP2 = viewport.worldToScreen(p2);

    // Draw axis line (dashed magenta)
    QPen axisPen(QColor(255, 0, 255));  // Magenta
    axisPen.setWidth(AXIS_LINE_WIDTH);
    axisPen.setStyle(Qt::DashLine);
    axisPen.setDashPattern({8, 4});
    painter.setPen(axisPen);
    painter.drawLine(screenP1, screenP2);

    // Draw axis point markers
    painter.setPen(QPen(QColor(255, 0, 255), 2));
    painter.setBrush(Qt::NoBrush);

    // First point: filled circle
    painter.setBrush(QColor(255, 0, 255));
    painter.drawEllipse(screenP1, POINT_MARKER_SIZE / 2.0, POINT_MARKER_SIZE / 2.0);

    // Second point: hollow circle
    painter.setBrush(Qt::NoBrush);
    painter.drawEllipse(screenP2, POINT_MARKER_SIZE / 2.0, POINT_MARKER_SIZE / 2.0);
}

void MirrorTool::renderMirroredEntitiesPreview(QPainter& painter, const Viewport& viewport) {
    if (!documentModel_ || !axisPoint1_ || !currentPoint_) {
        return;
    }

    // Preview pen: semi-transparent
    QPen previewPen(QColor(255, 100, 255, 150));  // Light magenta, semi-transparent
    previewPen.setWidth(PREVIEW_LINE_WIDTH);
    previewPen.setStyle(Qt::DashLine);
    previewPen.setDashPattern({4, 4});
    painter.setPen(previewPen);
    painter.setBrush(Qt::NoBrush);

    for (const auto& handle : selectedHandles_) {
        renderEntityMirrored(painter, viewport, handle);
    }
}

void MirrorTool::renderEntityMirrored(
    QPainter& painter,
    const Viewport& viewport,
    const std::string& handle
) {
    const auto* entityMeta = documentModel_->findEntityByHandle(handle);
    if (!entityMeta) {
        return;
    }

    Point2D axisP1 = *axisPoint1_;
    Point2D axisP2 = *currentPoint_;

    std::visit([&](auto&& entity) {
        using T = std::decay_t<decltype(entity)>;

        if constexpr (std::is_same_v<T, Line2D>) {
            auto mirrored = GeometryMath::mirror(entity, axisP1, axisP2);
            if (mirrored) {
                QPointF screenStart = viewport.worldToScreen(mirrored->start());
                QPointF screenEnd = viewport.worldToScreen(mirrored->end());
                painter.drawLine(screenStart, screenEnd);
            }
        }
        else if constexpr (std::is_same_v<T, Arc2D>) {
            auto mirrored = GeometryMath::mirror(entity, axisP1, axisP2);
            if (mirrored) {
                const int segments = 32;
                QPointF prevPoint;
                for (int i = 0; i <= segments; ++i) {
                    double t = static_cast<double>(i) / segments;
                    Point2D worldPt = mirrored->pointAt(t);
                    QPointF screenPt = viewport.worldToScreen(worldPt);
                    if (i > 0) {
                        painter.drawLine(prevPoint, screenPt);
                    }
                    prevPoint = screenPt;
                }
            }
        }
        else if constexpr (std::is_same_v<T, Ellipse2D>) {
            auto mirrored = GeometryMath::mirror(entity, axisP1, axisP2);
            if (mirrored) {
                const int segments = 48;
                QPointF prevPoint;
                for (int i = 0; i <= segments; ++i) {
                    double t = static_cast<double>(i) / segments;
                    Point2D worldPt = mirrored->pointAt(t);
                    QPointF screenPt = viewport.worldToScreen(worldPt);
                    if (i > 0) {
                        painter.drawLine(prevPoint, screenPt);
                    }
                    prevPoint = screenPt;
                }
            }
        }
        else if constexpr (std::is_same_v<T, Point2D>) {
            Point2D mirrored = GeometryMath::mirror(entity, axisP1, axisP2);
            QPointF screenPt = viewport.worldToScreen(mirrored);
            int size = 4;
            painter.drawLine(
                QPointF(screenPt.x() - size, screenPt.y() - size),
                QPointF(screenPt.x() + size, screenPt.y() + size)
            );
            painter.drawLine(
                QPointF(screenPt.x() - size, screenPt.y() + size),
                QPointF(screenPt.x() + size, screenPt.y() - size)
            );
        }
    }, entityMeta->entity);
}

bool MirrorTool::commitMirror() {
    if (!axisPoint1_ || !axisPoint2_ || !documentModel_) {
        qWarning() << "MirrorTool: Cannot commit - missing data";
        return false;
    }

    // Check for degenerate axis (same point)
    double axisDx = axisPoint2_->x() - axisPoint1_->x();
    double axisDy = axisPoint2_->y() - axisPoint1_->y();
    double axisLen = std::sqrt(axisDx * axisDx + axisDy * axisDy);

    if (axisLen < GEOMETRY_EPSILON) {
        qWarning() << "MirrorTool: Degenerate axis (same point)";
        return false;
    }

    // Use command system if available
    if (commandHistory_) {
        auto command = std::make_unique<Model::MirrorEntitiesCommand>(
            documentModel_,
            selectedHandles_,
            *axisPoint1_,
            *axisPoint2_,
            keepOriginal_
        );

        if (!commandHistory_->executeCommand(std::move(command))) {
            qWarning() << "MirrorTool: Failed to execute mirror command";
            return false;
        }
        qDebug() << "MirrorTool: Mirrored" << selectedHandles_.size()
                 << "entities, keepOriginal=" << keepOriginal_;
        return true;
    }

    qWarning() << "MirrorTool: No command history available";
    return false;
}

Point2D MirrorTool::calculateSelectionCenter() const {
    if (selectedHandles_.empty() || !documentModel_) {
        return Point2D(0, 0);
    }

    BoundingBox merged;
    bool first = true;

    for (const auto& handle : selectedHandles_) {
        const auto* entityMeta = documentModel_->findEntityByHandle(handle);
        if (!entityMeta) continue;

        std::optional<BoundingBox> bbox = std::visit([](auto&& entity) -> std::optional<BoundingBox> {
            using T = std::decay_t<decltype(entity)>;

            if constexpr (std::is_same_v<T, Line2D>) {
                return BoundingBox::fromLine(entity);
            } else if constexpr (std::is_same_v<T, Arc2D>) {
                return BoundingBox::fromArc(entity);
            } else if constexpr (std::is_same_v<T, Ellipse2D>) {
                return BoundingBox::fromEllipse(entity);
            } else if constexpr (std::is_same_v<T, Point2D>) {
                return BoundingBox::fromPoints(entity, entity);
            }
            return std::nullopt;
        }, entityMeta->entity);

        if (bbox) {
            if (first) {
                merged = *bbox;
                first = false;
            } else {
                merged = merged.merge(*bbox);
            }
        }
    }

    return merged.center();
}

void MirrorTool::resetToAxisPoint1() {
    axisPoint1_.reset();
    axisPoint2_.reset();
    currentPoint_.reset();
    mirrorState_ = MirrorState::WaitingForAxisPoint1;
}

void MirrorTool::cancel() {
    resetToAxisPoint1();
    selectedHandles_.clear();
    keepOriginal_ = false;
    mirrorState_ = MirrorState::Inactive;
}

} // namespace UI
} // namespace OwnCAD
```

### Step 3: Update CMakeLists.txt

Add to the source files:
```cmake
# In SOURCES section:
src/ui/MirrorTool.cpp

# In HEADERS section:
include/ui/MirrorTool.h
```

### Step 4: Register in ToolManager.cpp

```cpp
#include "ui/MirrorTool.h"

// In ToolManager constructor or registerDefaultTools():
registerTool("mirror", std::make_unique<MirrorTool>());
```

### Step 5: Add to main.cpp

```cpp
#include "ui/MirrorTool.h"

// In createMenus(), Tools menu section:
QAction* mirrorAction = toolsMenu->addAction("M&irror", this, &MainWindow::onMirrorTool);
mirrorAction->setShortcut(QKeySequence(Qt::Key_I));  // I for mIrror

// Add slot:
void onMirrorTool() {
    std::vector<std::string> selection = canvas_->selectedHandles();
    if (selection.empty()) {
        statusBar()->showMessage("MIRROR: Select entities first", 3000);
        return;
    }

    ToolManager* toolMgr = canvas_->toolManager();
    Tool* tool = toolMgr->tool("mirror");
    if (tool) {
        MirrorTool* mirrorTool = dynamic_cast<MirrorTool*>(tool);
        if (mirrorTool) {
            mirrorTool->setSelectedHandles(selection);
        }
    }

    toolMgr->activateTool("mirror");
    canvas_->setCursor(Qt::CrossCursor);
}
```

---

## Verification Checklist

### Manual Testing

1. **Basic Mirror:**
   - Select a line
   - Press I (Mirror tool)
   - Click two points to define axis
   - Verify line is mirrored

2. **Keep Original (Tab toggle):**
   - Select entities
   - Activate mirror
   - Press Tab (status should show "COPY")
   - Define axis
   - Verify both original and mirrored entities exist

3. **Quick Axis (X/Y keys):**
   - Select entities off-center
   - Press I, then X
   - Verify horizontal mirror through selection center
   - Undo, try Y for vertical

4. **Arc Direction Inversion:**
   - Create CCW arc
   - Mirror it
   - Verify mirrored arc is CW (critical for CNC)

5. **Undo/Redo:**
   - Mirror entities
   - Ctrl+Z → mirrored entities removed (or originals restored)
   - Ctrl+Y → mirror re-applied

6. **Cancel:**
   - Start mirror, press ESC after first point → returns to axis point 1
   - Press ESC again → exits tool

---

## Edge Cases

| Case | Expected Behavior |
|------|-------------------|
| Zero-length axis (same point) | Reject, show warning |
| Empty selection | Tool doesn't activate |
| Mixed entity types | All types mirrored correctly |
| Full circle arc | Mirrored, direction inverted |
| Ellipse | Mirrored (rotation angle adjusted) |

---

## Design Notes

1. **Why magenta preview?** Distinct from blue (selection) and other tool colors

2. **Why Tab for toggle?** Follows AutoCAD convention, doesn't conflict with other keys

3. **Why X/Y shortcuts?** Most mirrors are horizontal or vertical - speeds up workflow

4. **Arc direction inversion:** Mathematically correct - reflection reverses winding order

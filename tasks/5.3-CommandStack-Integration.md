# Task 5.3 - Command Stack Integration

## Quick Reference

| Item | Status | Notes |
|------|--------|-------|
| Command.h | ✅ EXISTS | `include/model/Command.h` |
| CommandHistory.h/cpp | ✅ EXISTS | `include/model/CommandHistory.h`, `src/model/CommandHistory.cpp` |
| EntityCommands.h/cpp | ✅ EXISTS | `include/model/EntityCommands.h`, `src/model/EntityCommands.cpp` |
| Tool → CommandHistory wiring | ❌ MISSING | Main deliverable of this task |
| ToolManager access to CommandHistory | ❌ MISSING | Needs implementation |

**First Action:** Wire CommandHistory to ToolManager, then to individual tools.

---

## Overview

This task connects the Command infrastructure (from 5.1) and concrete Commands (from 5.2) to the actual drawing/editing tools. After completion, all tool operations will go through the command system, enabling undo/redo.

**Goal:** Every tool commit creates a Command and executes it via CommandHistory.

---

## Objectives

- [ ] Provide CommandHistory access to ToolManager
- [ ] Wire LineTool to create `CreateEntityCommand` on commit
- [ ] Wire ArcTool to create `CreateEntityCommand` on commit
- [ ] Wire RectangleTool to create batch `CreateEntityCommand` (4 lines = 1 undo)
- [ ] Wire MoveTool to create `MoveEntitiesCommand` on commit
- [ ] Wire RotateTool to create `RotateEntitiesCommand` on commit
- [ ] Verify delete operation creates `DeleteEntitiesCommand`
- [ ] Test round-trip: Draw → Undo → Redo works for all tools

---

## Architecture

### Data Flow

```
User Action (click)
    │
    ▼
CADCanvas (mouse event)
    │
    ▼
ToolManager::handleMouseEvent()
    │
    ▼
ActiveTool (e.g., LineTool)
    │
    ├── Preview (no command, temp state)
    │
    └── Commit
         │
         ▼
    Create Command (e.g., CreateEntityCommand)
         │
         ▼
    CommandHistory::executeCommand()
         │
         ├── Command::execute() → Modifies DocumentModel
         │
         └── Push to undo stack
              │
              ▼
         Emit historyChanged()
              │
              ▼
         UI updates (menu, status bar)
```

### Ownership Diagram

```
MainWindow
    │
    ├── DocumentModel* (owns entities)
    │
    ├── CommandHistory* (owns Commands)
    │
    ├── ToolManager* (owns Tools)
    │       │
    │       ├── LineTool (has raw ptrs to DocumentModel, CommandHistory)
    │       ├── ArcTool
    │       ├── RectangleTool
    │       ├── MoveTool
    │       └── RotateTool
    │
    └── CADCanvas* (rendering, delegates input to ToolManager)
```

**CRITICAL:** Tools hold raw pointers to DocumentModel and CommandHistory. They must NOT outlive these objects.

---

## File Modifications

### Files to Modify

| File | Changes |
|------|---------|
| `ToolManager.h` | Add `setCommandHistory()`, store `CommandHistory*` |
| `ToolManager.cpp` | Pass CommandHistory to tools on creation/activation |
| `Tool.h` | Add `setCommandHistory()` virtual method or constructor param |
| `LineTool.h/cpp` | Add `m_commandHistory`, use in commit |
| `ArcTool.h/cpp` | Add `m_commandHistory`, use in commit |
| `RectangleTool.h/cpp` | Add `m_commandHistory`, use in commit |
| `MoveTool.h/cpp` | Add `m_commandHistory`, use in commit |
| `RotateTool.h/cpp` | Add `m_commandHistory`, use in commit |
| `main.cpp` | Connect CommandHistory to ToolManager |

---

## Implementation Steps

### Step 1: Extend Tool Base Class

Add CommandHistory support to the base Tool class:

**Tool.h additions:**
```cpp
class CommandHistory;  // Forward declaration

class Tool : public QObject {
    // ... existing code ...

public:
    /**
     * @brief Set command history for undo/redo support
     * @param history CommandHistory instance (non-owning)
     */
    void setCommandHistory(CommandHistory* history) { m_commandHistory = history; }

protected:
    CommandHistory* m_commandHistory = nullptr;
};
```

### Step 2: Update ToolManager

**ToolManager.h additions:**
```cpp
class CommandHistory;

class ToolManager : public QObject {
    Q_OBJECT

public:
    // ... existing code ...

    /**
     * @brief Set command history for all tools
     * @param history CommandHistory instance
     */
    void setCommandHistory(CommandHistory* history);

private:
    CommandHistory* m_commandHistory = nullptr;
};
```

**ToolManager.cpp additions:**
```cpp
void ToolManager::setCommandHistory(CommandHistory* history)
{
    m_commandHistory = history;

    // Update all registered tools
    for (auto& [name, tool] : m_tools) {
        tool->setCommandHistory(history);
    }
}
```

### Step 3: Wire LineTool

**LineTool.cpp - Replace direct DocumentModel call with Command:**

```cpp
#include "model/EntityCommands.h"
#include "model/CommandHistory.h"

void LineTool::commitLine()
{
    // Validate line
    auto lineOpt = Geometry::Line2D::create(m_firstPoint, m_secondPoint);
    if (!lineOpt) {
        emit statusUpdate("Cannot create zero-length line");
        resetState();
        return;
    }

    // Create command instead of direct model modification
    if (m_commandHistory) {
        auto command = std::make_unique<CreateEntityCommand>(
            m_documentModel,
            Import::GeometryEntity{*lineOpt},
            m_currentLayer  // or "0" if no layer system yet
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        // Fallback: direct add (for testing without undo)
        m_documentModel->addLine(*lineOpt, /* layer */ "0");
    }

    // Continue drawing or reset based on mode
    m_firstPoint = m_secondPoint;  // Chain mode: last point becomes first
    m_state = State::WaitingSecondPoint;

    emit statusUpdate("Line created. Click next point or ESC to finish.");
    emit requestRedraw();
}
```

### Step 4: Wire ArcTool

**ArcTool.cpp - Similar pattern:**

```cpp
#include "model/EntityCommands.h"
#include "model/CommandHistory.h"

void ArcTool::commitArc()
{
    auto arcOpt = Geometry::Arc2D::create(
        m_center, m_radius, m_startAngle, m_endAngle, m_direction
    );

    if (!arcOpt) {
        emit statusUpdate("Cannot create invalid arc");
        resetState();
        return;
    }

    if (m_commandHistory) {
        auto command = std::make_unique<CreateEntityCommand>(
            m_documentModel,
            Import::GeometryEntity{*arcOpt},
            m_currentLayer
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        m_documentModel->addArc(*arcOpt, "0");
    }

    resetState();
    emit statusUpdate("Arc created.");
    emit requestRedraw();
}
```

### Step 5: Wire RectangleTool (Batch Command)

Rectangle creates 4 lines. For clean undo, use a composite approach:

**Option A: CreateEntitiesCommand (Recommended)**

Add to EntityCommands.h:
```cpp
/**
 * @brief Creates multiple entities as a single undoable operation
 *
 * Used for composite shapes like rectangles (4 lines) or polylines.
 */
class CreateEntitiesCommand : public Command {
public:
    CreateEntitiesCommand(DocumentModel* model,
                          const std::vector<Import::GeometryEntity>& entities,
                          const std::string& layer = "0");

    bool execute() override;
    bool undo() override;
    QString description() const override;

private:
    std::vector<Import::GeometryEntity> m_entities;
    std::string m_layer;
    std::vector<std::string> m_generatedHandles;  // For undo
};
```

**RectangleTool.cpp:**
```cpp
void RectangleTool::commitRectangle()
{
    // Create 4 lines for rectangle corners
    std::vector<Import::GeometryEntity> lines;

    auto line1 = Geometry::Line2D::create(m_corner1, Point2D(m_corner2.x(), m_corner1.y()));
    auto line2 = Geometry::Line2D::create(Point2D(m_corner2.x(), m_corner1.y()), m_corner2);
    auto line3 = Geometry::Line2D::create(m_corner2, Point2D(m_corner1.x(), m_corner2.y()));
    auto line4 = Geometry::Line2D::create(Point2D(m_corner1.x(), m_corner2.y()), m_corner1);

    if (line1) lines.push_back(Import::GeometryEntity{*line1});
    if (line2) lines.push_back(Import::GeometryEntity{*line2});
    if (line3) lines.push_back(Import::GeometryEntity{*line3});
    if (line4) lines.push_back(Import::GeometryEntity{*line4});

    if (lines.size() != 4) {
        emit statusUpdate("Cannot create degenerate rectangle");
        resetState();
        return;
    }

    if (m_commandHistory) {
        auto command = std::make_unique<CreateEntitiesCommand>(
            m_documentModel, lines, m_currentLayer
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        // Fallback
        for (const auto& entity : lines) {
            std::visit([this](const auto& geom) {
                if constexpr (std::is_same_v<std::decay_t<decltype(geom)>, Geometry::Line2D>) {
                    m_documentModel->addLine(geom, "0");
                }
            }, entity);
        }
    }

    resetState();
    emit statusUpdate("Rectangle created (4 lines).");
    emit requestRedraw();
}
```

### Step 6: Wire MoveTool

**MoveTool.cpp:**
```cpp
#include "model/EntityCommands.h"
#include "model/CommandHistory.h"

void MoveTool::commitMove()
{
    if (m_selectedHandles.empty()) {
        deactivate();
        return;
    }

    double dx = m_destination.x() - m_basePoint.x();
    double dy = m_destination.y() - m_basePoint.y();

    // Skip if no movement
    if (std::abs(dx) < Geometry::GEOMETRY_EPSILON &&
        std::abs(dy) < Geometry::GEOMETRY_EPSILON) {
        emit statusUpdate("No movement detected");
        deactivate();
        return;
    }

    if (m_commandHistory) {
        auto command = std::make_unique<MoveEntitiesCommand>(
            m_documentModel,
            m_selectedHandles,
            dx, dy
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        // Fallback: direct modification (loses undo)
        applyMoveDirectly(dx, dy);
    }

    deactivate();
    emit statusUpdate(QString("Moved %1 entities").arg(m_selectedHandles.size()));
    emit requestRedraw();
}
```

### Step 7: Wire RotateTool

**RotateTool.cpp:**
```cpp
void RotateTool::commitRotation()
{
    if (m_selectedHandles.empty()) {
        deactivate();
        return;
    }

    if (m_commandHistory) {
        auto command = std::make_unique<RotateEntitiesCommand>(
            m_documentModel,
            m_selectedHandles,
            m_center,
            m_angleRadians
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        applyRotationDirectly();
    }

    deactivate();
    emit statusUpdate(QString("Rotated %1 entities by %2°")
        .arg(m_selectedHandles.size())
        .arg(qRadiansToDegrees(m_angleRadians), 0, 'f', 1));
    emit requestRedraw();
}
```

### Step 8: Wire Delete Operation

The delete operation (typically via Delete key) should also use commands:

**CADCanvas.cpp (or wherever delete is handled):**
```cpp
void CADCanvas::deleteSelectedEntities()
{
    auto handles = m_selectionManager->selectedHandles();
    if (handles.empty()) {
        return;
    }

    std::vector<std::string> handleVec(handles.begin(), handles.end());

    if (m_commandHistory) {
        auto command = std::make_unique<DeleteEntitiesCommand>(
            m_documentModel,
            handleVec
        );
        m_commandHistory->executeCommand(std::move(command));
    } else {
        for (const auto& handle : handleVec) {
            m_documentModel->removeEntity(handle);
        }
    }

    m_selectionManager->clear();
    emit selectionChanged();
    update();
}
```

### Step 9: Connect in main.cpp

**main.cpp:**
```cpp
// After creating CommandHistory and ToolManager:
CommandHistory* commandHistory = new CommandHistory(mainWindow);
ToolManager* toolManager = new ToolManager(documentModel, mainWindow);

// Wire them together
toolManager->setCommandHistory(commandHistory);

// Also provide to CADCanvas if delete is handled there
canvas->setCommandHistory(commandHistory);
```

---

## Verification Checklist

### Unit Tests

Create or extend `tests/model/test_CommandIntegration.cpp`:

```cpp
// Test tool → command → history flow
TEST(CommandIntegration, LineToolCreatesCommand)
{
    DocumentModel model;
    CommandHistory history;
    LineTool tool(&model);
    tool.setCommandHistory(&history);

    // Simulate drawing a line
    tool.activate();
    tool.handleMousePress(Point2D(0, 0), Qt::LeftButton, Qt::NoModifier);
    tool.handleMousePress(Point2D(100, 100), Qt::LeftButton, Qt::NoModifier);

    // Verify command was created
    EXPECT_EQ(history.undoCount(), 1);
    EXPECT_EQ(model.entityCount(), 1);

    // Undo
    EXPECT_TRUE(history.undo());
    EXPECT_EQ(model.entityCount(), 0);

    // Redo
    EXPECT_TRUE(history.redo());
    EXPECT_EQ(model.entityCount(), 1);
}

TEST(CommandIntegration, RectangleToolSingleUndo)
{
    // Rectangle = 4 lines, but should be 1 undo operation
    DocumentModel model;
    CommandHistory history;
    RectangleTool tool(&model);
    tool.setCommandHistory(&history);

    tool.activate();
    tool.handleMousePress(Point2D(0, 0), Qt::LeftButton, Qt::NoModifier);
    tool.handleMousePress(Point2D(100, 100), Qt::LeftButton, Qt::NoModifier);

    EXPECT_EQ(history.undoCount(), 1);  // Not 4!
    EXPECT_EQ(model.entityCount(), 4);   // 4 lines

    history.undo();
    EXPECT_EQ(model.entityCount(), 0);   // All 4 gone
}

TEST(CommandIntegration, MoveToolUndo)
{
    DocumentModel model;
    CommandHistory history;

    // Add a line
    auto line = Line2D::create(Point2D(0, 0), Point2D(100, 0));
    model.addLine(*line, "0");
    std::string handle = model.entities().back().handle;

    // Move it
    MoveTool tool(&model);
    tool.setCommandHistory(&history);
    tool.setSelectedHandles({handle});
    tool.activate();
    tool.handleMousePress(Point2D(0, 0), Qt::LeftButton, Qt::NoModifier);
    tool.handleMousePress(Point2D(50, 50), Qt::LeftButton, Qt::NoModifier);

    // Verify moved
    auto* entity = model.findEntityByHandle(handle);
    auto& movedLine = std::get<Line2D>(entity->entity);
    EXPECT_DOUBLE_EQ(movedLine.start().x(), 50.0);

    // Undo
    history.undo();
    entity = model.findEntityByHandle(handle);
    auto& originalLine = std::get<Line2D>(entity->entity);
    EXPECT_DOUBLE_EQ(originalLine.start().x(), 0.0);  // Back to original
}
```

### Manual Testing

1. **LineTool:**
   - [ ] Draw a line
   - [ ] Press Ctrl+Z → Line disappears
   - [ ] Press Ctrl+Y → Line reappears
   - [ ] Draw multiple lines → Multiple Ctrl+Z removes them in reverse order

2. **ArcTool:**
   - [ ] Draw an arc (3 clicks)
   - [ ] Ctrl+Z → Arc disappears
   - [ ] Ctrl+Y → Arc reappears

3. **RectangleTool:**
   - [ ] Draw a rectangle
   - [ ] Verify 4 lines created
   - [ ] Single Ctrl+Z removes ALL 4 lines
   - [ ] Ctrl+Y restores ALL 4 lines

4. **MoveTool:**
   - [ ] Select entity, move it
   - [ ] Ctrl+Z → Entity returns to original position
   - [ ] Ctrl+Y → Entity moves again

5. **RotateTool:**
   - [ ] Select entity, rotate it
   - [ ] Ctrl+Z → Entity returns to original angle
   - [ ] Ctrl+Y → Entity rotates again

6. **Delete:**
   - [ ] Select entities, press Delete
   - [ ] Ctrl+Z → Entities restored
   - [ ] Ctrl+Y → Entities deleted again

7. **Mixed Operations:**
   - [ ] Draw line → Move → Rotate → Delete
   - [ ] Ctrl+Z four times → Back to empty
   - [ ] Ctrl+Y four times → All operations reapplied

---

## Edge Cases

### Tool Cancellation
When user presses ESC during tool operation:
- No command should be created
- Preview state should be cleared
- Undo stack should remain unchanged

### Zero-Movement Operations
If user clicks same point twice in MoveTool:
- Skip command creation (no-op)
- Don't pollute undo stack

### Invalid Geometry
If tool produces invalid geometry (e.g., zero-length line):
- Reject operation
- Show error message
- Don't create command

### Tool Without CommandHistory
If CommandHistory is null (defensive):
- Log warning
- Fall back to direct DocumentModel modification
- Operation works but loses undo capability

---

## Dependencies

### Required Before This Task
- Task 5.1: Command Pattern Architecture (✅ EXISTS)
- Task 5.2: Command Implementations (✅ EXISTS)
- Drawing tools functional (LineTool, ArcTool, RectangleTool) (✅ EXISTS)
- Transformation tools functional (MoveTool, RotateTool) (✅ EXISTS)

### Required After This Task
- Task 5.4: UI Integration (keyboard shortcuts, menus)
- Task 5.5: Stress Testing (robustness verification)

---

## Summary

| Tool | Command Type | Entities Affected |
|------|--------------|-------------------|
| LineTool | CreateEntityCommand | 1 line |
| ArcTool | CreateEntityCommand | 1 arc |
| RectangleTool | CreateEntitiesCommand | 4 lines (batch) |
| MoveTool | MoveEntitiesCommand | N entities |
| RotateTool | RotateEntitiesCommand | N entities |
| Delete | DeleteEntitiesCommand | N entities |

**Key Principle:** All state-modifying operations go through CommandHistory. No direct DocumentModel mutations after this task is complete.

---

END OF TASK 5.3

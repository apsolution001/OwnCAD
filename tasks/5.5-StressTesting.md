# Task 5.5 - Undo/Redo Stress Testing

## Quick Reference

| Item | Status | Notes |
|------|--------|-------|
| CommandHistory | ✅ EXISTS | Must withstand 100+ cycles |
| EntityCommands | ✅ EXISTS | Must preserve geometry exactly |
| Tool integration | From 5.3 | All tools must be wired |
| UI integration | From 5.4 | Shortcuts and menu working |
| Stress tests | ❌ MISSING | Main deliverable |

**First Action:** Create automated stress test suite.

---

## Overview

This task validates the robustness of the undo/redo system through:
- High-volume cycle testing (100+ operations)
- Random operation sequences
- Memory leak detection
- Geometry integrity verification
- Edge case fuzzing

**Goal:** Undo/redo is "unbreakable" under all conditions.

---

## Objectives

- [ ] Test 100+ sequential undo/redo cycles
- [ ] Test random operation sequences (draw, move, rotate, delete, undo, redo)
- [ ] Verify no memory leaks after extended use
- [ ] Verify geometry integrity after undo/redo (compare to original)
- [ ] Test boundary conditions (empty stack, max stack, rapid operations)
- [ ] Document any found issues and fixes

---

## Test Categories

### Category 1: Volume Testing
Verify system handles large numbers of operations.

### Category 2: Sequence Testing
Verify correct behavior with various operation orderings.

### Category 3: Memory Testing
Verify no leaks or excessive memory growth.

### Category 4: Integrity Testing
Verify geometry is exactly preserved through undo/redo.

### Category 5: Edge Case Testing
Verify graceful handling of boundary conditions.

---

## Test Implementation

### File Location

Create: `tests/model/test_UndoRedoStress.cpp`

### Test Framework

Use Qt Test framework (consistent with existing tests):

```cpp
#include <QtTest>
#include "model/DocumentModel.h"
#include "model/CommandHistory.h"
#include "model/EntityCommands.h"
#include "geometry/Line2D.h"
#include "geometry/Arc2D.h"
#include "geometry/Point2D.h"
#include "geometry/GeometryMath.h"
#include <random>
#include <chrono>

using namespace OwnCAD::Geometry;

class TestUndoRedoStress : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    // Volume tests
    void test100UndoRedoCycles();
    void test500Operations();
    void testMaxStackSize();

    // Sequence tests
    void testRandomOperationSequence();
    void testInterleavedUndoRedo();
    void testUndoAllRedoAll();

    // Memory tests
    void testMemoryStability();
    void testNoLeaksAfterClear();

    // Integrity tests
    void testGeometryPreservedAfterUndo();
    void testArcDirectionPreserved();
    void test360RotationIdentity();
    void testMoveUndoExactRestore();

    // Edge case tests
    void testUndoOnEmptyStack();
    void testRedoOnEmptyStack();
    void testRapidUndoRedo();
    void testUndoRedoAfterClear();

private:
    DocumentModel* m_model = nullptr;
    CommandHistory* m_history = nullptr;
    std::mt19937 m_rng;

    // Helpers
    void addRandomLine();
    void addRandomArc();
    void moveRandomEntity(double dx, double dy);
    void rotateRandomEntity(double angle);
    void deleteRandomEntity();
    bool compareGeometry(const Import::GeometryEntity& a,
                         const Import::GeometryEntity& b,
                         double tolerance = 1e-9);
};
```

---

## Volume Tests

### Test 1: 100 Undo/Redo Cycles

```cpp
void TestUndoRedoStress::test100UndoRedoCycles()
{
    // Create 100 lines
    for (int i = 0; i < 100; ++i) {
        auto line = Line2D::create(Point2D(i, 0), Point2D(i, 100));
        QVERIFY(line.has_value());

        auto cmd = std::make_unique<CreateEntityCommand>(
            m_model,
            Import::GeometryEntity{*line},
            "0"
        );
        QVERIFY(m_history->executeCommand(std::move(cmd)));
    }

    QCOMPARE(m_model->entityCount(), 100u);
    QCOMPARE(m_history->undoCount(), 100u);

    // Undo all 100
    for (int i = 0; i < 100; ++i) {
        QVERIFY2(m_history->undo(),
                 qPrintable(QString("Undo failed at iteration %1").arg(i)));
    }

    QCOMPARE(m_model->entityCount(), 0u);
    QCOMPARE(m_history->redoCount(), 100u);

    // Redo all 100
    for (int i = 0; i < 100; ++i) {
        QVERIFY2(m_history->redo(),
                 qPrintable(QString("Redo failed at iteration %1").arg(i)));
    }

    QCOMPARE(m_model->entityCount(), 100u);
    QCOMPARE(m_history->undoCount(), 100u);
}
```

### Test 2: 500 Mixed Operations

```cpp
void TestUndoRedoStress::test500Operations()
{
    const int TOTAL_OPS = 500;

    for (int i = 0; i < TOTAL_OPS; ++i) {
        int opType = m_rng() % 4;

        switch (opType) {
            case 0: addRandomLine(); break;
            case 1: addRandomArc(); break;
            case 2:
                if (m_model->entityCount() > 0) {
                    moveRandomEntity(10.0, 10.0);
                } else {
                    addRandomLine();
                }
                break;
            case 3:
                if (m_model->entityCount() > 5) {
                    deleteRandomEntity();
                } else {
                    addRandomLine();
                }
                break;
        }
    }

    // Record state
    size_t finalCount = m_model->entityCount();
    size_t undoDepth = m_history->undoCount();

    // Undo everything
    while (m_history->canUndo()) {
        QVERIFY(m_history->undo());
    }

    QCOMPARE(m_model->entityCount(), 0u);

    // Redo everything
    while (m_history->canRedo()) {
        QVERIFY(m_history->redo());
    }

    // Should be back to original state
    QCOMPARE(m_model->entityCount(), finalCount);
}
```

### Test 3: Max Stack Size

```cpp
void TestUndoRedoStress::testMaxStackSize()
{
    // Set small max for testing
    m_history->setMaxHistorySize(50);

    // Add 100 operations
    for (int i = 0; i < 100; ++i) {
        addRandomLine();
    }

    // Should only have 50 in undo stack
    QCOMPARE(m_history->undoCount(), 50u);

    // Oldest 50 operations are lost (by design)
    // But newest 50 should undo correctly
    for (int i = 0; i < 50; ++i) {
        QVERIFY(m_history->undo());
    }

    // Can't undo more
    QVERIFY(!m_history->canUndo());

    // Restore default
    m_history->setMaxHistorySize(100);
}
```

---

## Sequence Tests

### Test 4: Random Operation Sequence

```cpp
void TestUndoRedoStress::testRandomOperationSequence()
{
    // Seed for reproducibility
    m_rng.seed(42);

    const int ITERATIONS = 200;

    for (int i = 0; i < ITERATIONS; ++i) {
        int action = m_rng() % 10;

        if (action < 4) {
            // 40% chance: add entity
            if (m_rng() % 2 == 0) {
                addRandomLine();
            } else {
                addRandomArc();
            }
        } else if (action < 6) {
            // 20% chance: undo
            if (m_history->canUndo()) {
                QVERIFY(m_history->undo());
            }
        } else if (action < 8) {
            // 20% chance: redo
            if (m_history->canRedo()) {
                QVERIFY(m_history->redo());
            }
        } else if (action < 9) {
            // 10% chance: move
            if (m_model->entityCount() > 0) {
                double dx = (m_rng() % 100) - 50;
                double dy = (m_rng() % 100) - 50;
                moveRandomEntity(dx, dy);
            }
        } else {
            // 10% chance: delete
            if (m_model->entityCount() > 0) {
                deleteRandomEntity();
            }
        }
    }

    // System should still be consistent
    QVERIFY(m_model->entityCount() >= 0);

    // Full undo should work
    while (m_history->canUndo()) {
        QVERIFY(m_history->undo());
    }
}
```

### Test 5: Interleaved Undo/Redo

```cpp
void TestUndoRedoStress::testInterleavedUndoRedo()
{
    // Create 10 entities
    for (int i = 0; i < 10; ++i) {
        addRandomLine();
    }

    // Interleaved pattern: undo 2, redo 1, undo 2, redo 1...
    for (int i = 0; i < 5; ++i) {
        QVERIFY(m_history->undo());
        QVERIFY(m_history->undo());
        QVERIFY(m_history->redo());
    }

    // Should have net undone 5 operations
    QCOMPARE(m_model->entityCount(), 5u);
}
```

### Test 6: Undo All, Redo All

```cpp
void TestUndoRedoStress::testUndoAllRedoAll()
{
    // Mixed operations
    addRandomLine();
    addRandomArc();
    addRandomLine();
    moveRandomEntity(50, 50);
    addRandomArc();

    // Capture final state snapshots
    std::vector<Import::GeometryEntityWithMetadata> finalState;
    for (const auto& entity : m_model->entities()) {
        finalState.push_back(entity);
    }

    // Undo all
    while (m_history->canUndo()) {
        QVERIFY(m_history->undo());
    }
    QCOMPARE(m_model->entityCount(), 0u);

    // Redo all
    while (m_history->canRedo()) {
        QVERIFY(m_history->redo());
    }

    // Compare to final state
    QCOMPARE(m_model->entityCount(), finalState.size());

    // Note: Handles may differ after redo, but geometry should match
    // (This is acceptable per design decision in 5.2)
}
```

---

## Memory Tests

### Test 7: Memory Stability

```cpp
void TestUndoRedoStress::testMemoryStability()
{
    // This test requires manual memory observation or tools like Valgrind
    // Here we do a basic allocation pattern test

    const int CYCLES = 50;

    for (int cycle = 0; cycle < CYCLES; ++cycle) {
        // Add 20 entities
        for (int i = 0; i < 20; ++i) {
            addRandomLine();
        }

        // Undo all
        while (m_history->canUndo()) {
            m_history->undo();
        }

        // Redo all
        while (m_history->canRedo()) {
            m_history->redo();
        }

        // Clear everything
        m_history->clear();
        m_model->clear();
    }

    // If we got here without crash or hang, basic stability is OK
    QVERIFY(true);
}
```

### Test 8: No Leaks After Clear

```cpp
void TestUndoRedoStress::testNoLeaksAfterClear()
{
    // Add operations
    for (int i = 0; i < 100; ++i) {
        addRandomLine();
    }

    // Undo some
    for (int i = 0; i < 50; ++i) {
        m_history->undo();
    }

    // Now we have both undo and redo stacks populated
    QCOMPARE(m_history->undoCount(), 50u);
    QCOMPARE(m_history->redoCount(), 50u);

    // Clear
    m_history->clear();

    QCOMPARE(m_history->undoCount(), 0u);
    QCOMPARE(m_history->redoCount(), 0u);

    // Commands should be destroyed, not leaked
    // (Verified via Valgrind in CI or manual testing)
}
```

---

## Integrity Tests

### Test 9: Geometry Preserved After Undo

```cpp
void TestUndoRedoStress::testGeometryPreservedAfterUndo()
{
    // Create specific geometry
    Point2D p1(100.123456789, 200.987654321);
    Point2D p2(300.111111111, 400.222222222);
    auto line = Line2D::create(p1, p2);
    QVERIFY(line.has_value());

    auto cmd = std::make_unique<CreateEntityCommand>(
        m_model, Import::GeometryEntity{*line}, "0"
    );
    m_history->executeCommand(std::move(cmd));

    // Get the created entity
    QCOMPARE(m_model->entityCount(), 1u);
    auto original = m_model->entities()[0];
    auto& originalLine = std::get<Line2D>(original.entity);

    // Undo
    m_history->undo();
    QCOMPARE(m_model->entityCount(), 0u);

    // Redo
    m_history->redo();
    QCOMPARE(m_model->entityCount(), 1u);

    // Compare geometry (handle may differ)
    auto& restoredLine = std::get<Line2D>(m_model->entities()[0].entity);

    // Must be exactly equal (within epsilon)
    QVERIFY(originalLine.start().isEqual(restoredLine.start()));
    QVERIFY(originalLine.end().isEqual(restoredLine.end()));

    // Full precision comparison
    QCOMPARE(originalLine.start().x(), restoredLine.start().x());
    QCOMPARE(originalLine.start().y(), restoredLine.start().y());
    QCOMPARE(originalLine.end().x(), restoredLine.end().x());
    QCOMPARE(originalLine.end().y(), restoredLine.end().y());
}
```

### Test 10: Arc Direction Preserved

```cpp
void TestUndoRedoStress::testArcDirectionPreserved()
{
    // Create CCW arc
    auto ccwArc = Arc2D::create(Point2D(0, 0), 100.0, 0.0, M_PI, true);
    QVERIFY(ccwArc.has_value());
    QVERIFY(ccwArc->isCounterClockwise());

    auto cmd1 = std::make_unique<CreateEntityCommand>(
        m_model, Import::GeometryEntity{*ccwArc}, "0"
    );
    m_history->executeCommand(std::move(cmd1));

    // Create CW arc
    auto cwArc = Arc2D::create(Point2D(200, 0), 50.0, 0.0, M_PI, false);
    QVERIFY(cwArc.has_value());
    QVERIFY(!cwArc->isCounterClockwise());

    auto cmd2 = std::make_unique<CreateEntityCommand>(
        m_model, Import::GeometryEntity{*cwArc}, "0"
    );
    m_history->executeCommand(std::move(cmd2));

    // Undo both
    m_history->undo();
    m_history->undo();

    // Redo both
    m_history->redo();
    m_history->redo();

    // Check directions preserved
    auto& arc1 = std::get<Arc2D>(m_model->entities()[0].entity);
    auto& arc2 = std::get<Arc2D>(m_model->entities()[1].entity);

    QVERIFY(arc1.isCounterClockwise());   // CCW preserved
    QVERIFY(!arc2.isCounterClockwise());  // CW preserved
}
```

### Test 11: 360° Rotation Identity

```cpp
void TestUndoRedoStress::test360RotationIdentity()
{
    // Create a line
    Point2D p1(100.0, 100.0);
    Point2D p2(200.0, 100.0);
    auto line = Line2D::create(p1, p2);
    QVERIFY(line.has_value());

    auto createCmd = std::make_unique<CreateEntityCommand>(
        m_model, Import::GeometryEntity{*line}, "0"
    );
    m_history->executeCommand(std::move(createCmd));

    std::string handle = m_model->entities()[0].handle;

    // Rotate by 360 degrees (full circle)
    Point2D center(150.0, 100.0);
    double fullRotation = 2.0 * M_PI;

    auto rotateCmd = std::make_unique<RotateEntitiesCommand>(
        m_model,
        std::vector<std::string>{handle},
        center,
        fullRotation
    );
    m_history->executeCommand(std::move(rotateCmd));

    // Line should be identical to original (within tolerance)
    auto* entity = m_model->findEntityByHandle(handle);
    QVERIFY(entity != nullptr);

    auto& rotatedLine = std::get<Line2D>(entity->entity);

    // 360° rotation should give identical geometry
    QVERIFY(p1.isEqual(rotatedLine.start(), 1e-6));
    QVERIFY(p2.isEqual(rotatedLine.end(), 1e-6));

    // Undo should also give identical geometry
    m_history->undo();
    entity = m_model->findEntityByHandle(handle);
    auto& undoLine = std::get<Line2D>(entity->entity);

    QVERIFY(p1.isEqual(undoLine.start(), 1e-9));
    QVERIFY(p2.isEqual(undoLine.end(), 1e-9));
}
```

### Test 12: Move Undo Exact Restore

```cpp
void TestUndoRedoStress::testMoveUndoExactRestore()
{
    // Create line at exact position
    Point2D p1(123.456789012345, 234.567890123456);
    Point2D p2(345.678901234567, 456.789012345678);
    auto line = Line2D::create(p1, p2);
    QVERIFY(line.has_value());

    auto createCmd = std::make_unique<CreateEntityCommand>(
        m_model, Import::GeometryEntity{*line}, "0"
    );
    m_history->executeCommand(std::move(createCmd));

    std::string handle = m_model->entities()[0].handle;

    // Move by arbitrary amount
    double dx = 17.123456789;
    double dy = -23.987654321;

    auto moveCmd = std::make_unique<MoveEntitiesCommand>(
        m_model,
        std::vector<std::string>{handle},
        dx, dy
    );
    m_history->executeCommand(std::move(moveCmd));

    // Undo
    m_history->undo();

    // Should be exactly at original position
    auto* entity = m_model->findEntityByHandle(handle);
    auto& restoredLine = std::get<Line2D>(entity->entity);

    // Exact comparison (no accumulated error)
    QCOMPARE(restoredLine.start().x(), p1.x());
    QCOMPARE(restoredLine.start().y(), p1.y());
    QCOMPARE(restoredLine.end().x(), p2.x());
    QCOMPARE(restoredLine.end().y(), p2.y());
}
```

---

## Edge Case Tests

### Test 13: Undo on Empty Stack

```cpp
void TestUndoRedoStress::testUndoOnEmptyStack()
{
    QVERIFY(!m_history->canUndo());
    QVERIFY(!m_history->undo());  // Should return false, not crash

    // Add and remove one operation
    addRandomLine();
    m_history->undo();

    QVERIFY(!m_history->canUndo());
    QVERIFY(!m_history->undo());  // Still safe
}
```

### Test 14: Redo on Empty Stack

```cpp
void TestUndoRedoStress::testRedoOnEmptyStack()
{
    QVERIFY(!m_history->canRedo());
    QVERIFY(!m_history->redo());  // Should return false, not crash

    // Add operation (clears redo stack)
    addRandomLine();

    QVERIFY(!m_history->canRedo());
    QVERIFY(!m_history->redo());  // Still safe
}
```

### Test 15: Rapid Undo/Redo

```cpp
void TestUndoRedoStress::testRapidUndoRedo()
{
    // Simulate rapid key presses
    for (int i = 0; i < 50; ++i) {
        addRandomLine();
    }

    // Rapid alternating undo/redo (like holding both keys)
    for (int i = 0; i < 100; ++i) {
        if (i % 2 == 0) {
            m_history->undo();
        } else {
            m_history->redo();
        }
    }

    // Should be stable
    QVERIFY(m_model->entityCount() >= 0);
}
```

### Test 16: Undo/Redo After Clear

```cpp
void TestUndoRedoStress::testUndoRedoAfterClear()
{
    addRandomLine();
    addRandomLine();
    m_history->undo();

    // Clear with items in both stacks
    m_history->clear();

    // Should be safe to call undo/redo
    QVERIFY(!m_history->undo());
    QVERIFY(!m_history->redo());

    // New operations should work
    addRandomLine();
    QCOMPARE(m_history->undoCount(), 1u);
    QVERIFY(m_history->undo());
}
```

---

## Helper Implementations

```cpp
void TestUndoRedoStress::addRandomLine()
{
    double x1 = m_rng() % 1000;
    double y1 = m_rng() % 1000;
    double x2 = x1 + (m_rng() % 100) + 1;  // Ensure non-zero length
    double y2 = y1 + (m_rng() % 100) + 1;

    auto line = Line2D::create(Point2D(x1, y1), Point2D(x2, y2));
    if (line) {
        auto cmd = std::make_unique<CreateEntityCommand>(
            m_model, Import::GeometryEntity{*line}, "0"
        );
        m_history->executeCommand(std::move(cmd));
    }
}

void TestUndoRedoStress::addRandomArc()
{
    double cx = m_rng() % 1000;
    double cy = m_rng() % 1000;
    double radius = (m_rng() % 100) + 10;
    double startAngle = (m_rng() % 360) * M_PI / 180.0;
    double endAngle = startAngle + ((m_rng() % 180) + 30) * M_PI / 180.0;
    bool ccw = m_rng() % 2 == 0;

    auto arc = Arc2D::create(Point2D(cx, cy), radius, startAngle, endAngle, ccw);
    if (arc) {
        auto cmd = std::make_unique<CreateEntityCommand>(
            m_model, Import::GeometryEntity{*arc}, "0"
        );
        m_history->executeCommand(std::move(cmd));
    }
}

void TestUndoRedoStress::moveRandomEntity(double dx, double dy)
{
    if (m_model->entities().empty()) return;

    size_t idx = m_rng() % m_model->entities().size();
    std::string handle = m_model->entities()[idx].handle;

    auto cmd = std::make_unique<MoveEntitiesCommand>(
        m_model, std::vector<std::string>{handle}, dx, dy
    );
    m_history->executeCommand(std::move(cmd));
}

void TestUndoRedoStress::deleteRandomEntity()
{
    if (m_model->entities().empty()) return;

    size_t idx = m_rng() % m_model->entities().size();
    std::string handle = m_model->entities()[idx].handle;

    auto cmd = std::make_unique<DeleteEntityCommand>(m_model, handle);
    m_history->executeCommand(std::move(cmd));
}

void TestUndoRedoStress::init()
{
    m_model = new DocumentModel();
    m_history = new CommandHistory();
    m_rng.seed(std::chrono::steady_clock::now().time_since_epoch().count());
}

void TestUndoRedoStress::cleanup()
{
    delete m_history;
    delete m_model;
    m_history = nullptr;
    m_model = nullptr;
}
```

---

## CMakeLists.txt Addition

```cmake
# Add stress test executable
add_executable(test_UndoRedoStress
    tests/model/test_UndoRedoStress.cpp
)

target_link_libraries(test_UndoRedoStress PRIVATE
    Qt6::Core
    Qt6::Test
    # Link to your library containing DocumentModel, CommandHistory, etc.
)

add_test(NAME UndoRedoStress COMMAND test_UndoRedoStress)
```

---

## Manual Testing Checklist

### Extended Session Testing

- [ ] Run application for 30+ minutes with continuous drawing/editing
- [ ] Perform 100+ undo operations in sequence
- [ ] Perform 100+ redo operations in sequence
- [ ] Mix operations randomly for 15+ minutes
- [ ] Monitor memory usage (should remain stable, not grow unbounded)

### Visual Verification

- [ ] After 50 undo/redo cycles, geometry appears correct
- [ ] No visual artifacts or rendering glitches
- [ ] Snap points still work correctly after undo/redo
- [ ] Selection state is consistent after undo/redo

### Error Recovery

- [ ] Force application to background during operation, resume works
- [ ] Minimize/maximize window during undo/redo, no issues
- [ ] Resize window during undo/redo, no issues

---

## Performance Benchmarks (Optional)

```cpp
void TestUndoRedoStress::benchmarkUndoSpeed()
{
    // Add 1000 entities
    for (int i = 0; i < 1000; ++i) {
        addRandomLine();
    }

    // Time 1000 undos
    auto start = std::chrono::high_resolution_clock::now();

    while (m_history->canUndo()) {
        m_history->undo();
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    qDebug() << "1000 undos took:" << duration.count() << "ms";

    // Should complete in reasonable time (< 5 seconds)
    QVERIFY(duration.count() < 5000);
}
```

---

## Known Issues / Limitations

Document any issues found during testing:

| Issue | Severity | Status | Notes |
|-------|----------|--------|-------|
| (none yet) | - | - | - |

---

## Success Criteria

The undo/redo system passes stress testing when:

1. **Volume:** 100+ operations handled without error
2. **Sequences:** Random operation sequences complete without crash
3. **Memory:** No leaks detected (via Valgrind or equivalent)
4. **Integrity:** Geometry is bit-exact after undo (within epsilon)
5. **Edge cases:** All boundary conditions handled gracefully
6. **Performance:** 1000 operations undo in < 5 seconds

---

## Dependencies

### Required Before This Task
- Task 5.1: Command Pattern Architecture (✅)
- Task 5.2: Command Implementations (✅)
- Task 5.3: Command Stack Integration (tools wired)
- Task 5.4: UI Integration (keyboard shortcuts working)

### After This Task
- Phase 1 Section 5 (Undo/Redo) is COMPLETE
- Can proceed to Section 6 (Duplicate Detection)

---

END OF TASK 5.5
